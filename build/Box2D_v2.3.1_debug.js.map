{"version":3,"file":"build/Box2D_v2.3.1_debug.js","sources":["./box2d_glue.cpp","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2Joint.h","Box2D_v2.3.1/Box2D/Common/b2Math.h","Box2D_v2.3.1/Box2D/Collision/Shapes/b2Shape.h","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2DistanceJoint.h","Box2D_v2.3.1/Box2D/Dynamics/b2Fixture.h","Box2D_v2.3.1/Box2D/Dynamics/b2Body.h","Box2D_v2.3.1/Box2D/Collision/b2Collision.h","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2FrictionJoint.h","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2PrismaticJoint.h","Box2D_v2.3.1/Box2D/Dynamics/b2World.h","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2WheelJoint.h","Box2D_v2.3.1/Box2D/Collision/Shapes/b2CircleShape.h","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2WeldJoint.h","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2GearJoint.h","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2PulleyJoint.h","Box2D_v2.3.1/Box2D/Collision/Shapes/b2ChainShape.h","Box2D_v2.3.1/Box2D/Common/b2Draw.h","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2RopeJoint.h","Box2D_v2.3.1/Box2D/Collision/Shapes/b2PolygonShape.h","Box2D_v2.3.1/Box2D/Collision/Shapes/b2EdgeShape.h","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2RevoluteJoint.h","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2MouseJoint.h","Box2D_v2.3.1/Box2D/Dynamics/Contacts/b2Contact.h","Box2D_v2.3.1/Box2D/Dynamics/Joints/b2MotorJoint.h","glue_stub.cpp","Box2D_v2.3.1/Box2D/Dynamics/b2WorldCallbacks.h"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4LA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAKA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AC7BA;AAAA;AAAA;;;;;;;;ADiCA;AAAA;AAAA;;;;;;;;;AC5BA;AAAA;AAAA;;;;;;;;ADgCA;AAAA;AAAA;;;;;;;;;AC3BA;AAAA;AAAA;;;;;;;;;AD+BA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AE9KA;;;;;;;;;AFkLA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AC7CA;AAAA;AAAA;;;;;;;;ADiDA;AAAA;AAAA;;;;;;;;;ACvCA;AAAA;AAAA;;;;;;;;;;AD2CA;AAAA;AAAA;AACA;;;;;;;;;;;ACvCA;AAAA;AAAA;AACA;;;;;;;;ADyCA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;ACzCA;AAAA;AAAA;AAAA;;;;;;;;AD6CA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;ACtNA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;ADqNA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AGpPA;AAAA;AAAA;;;;;;;;AHwPA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;AAtYA;;AAAA;AAAA;;;;;;;;;;AA0YA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AIvVA;AAAA;;;;;;;;AJ2VA;AAAA;AAAA;;;;;;;;;AIxVA;AAAA;;;;;;;;;;AJ4VA;AAAA;AAAA;AACA;;;;;;;;;;;AItSA;AAAA;AAAA;AACA;;;;;;;;AJwSA;AAAA;AAAA;;;;;;;;;AIpSA;AAAA;AAAA;;;;;;;;;;AJwSA;AAAA;AAAA;AACA;;;;;;;;;;;AIpSA;AAAA;AAAA;AACA;;;;;;;;AJsSA;AAAA;AAAA;;;;;;;;;AIlSA;AAAA;AAAA;;;;;;;;;;AJsSA;AAAA;AAAA;AACA;;;;;;;;;;;AIlSA;AAAA;AAAA;AACA;;;;;;;;AJoSA;AAAA;AAAA;;;;;;;;;AIhSA;AAAA;AAAA;;;;;;;;AJoSA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AE/PA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AFmQA;AAAA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;AEhQA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AF+PA;AAAA;AACA;;;;;;;;;AE3PA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AF2PA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AE7XA;;;;;;;;;;;AFiYA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AK/UA;AAAA;AAAA;AAAA;;;;;;;;ALmVA;AAAA;AAAA;;;;;;;;;AK9UA;AAAA;AAAA;;;;;;;;;;;ALkVA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AK5UA;AAAA;AAAA;AAAA;;;;;;;;;;ALgVA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AK/UA;AAAA;;;;;;;;ALmVA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AKxUA;AAAA;AAAA;;;;;;;;AL4UA;AAAA;AAAA;;;;;;;;;AKlUA;AAAA;AAAA;;;;;;;;ALsUA;AAAA;AAAA;;;;;;;;;AK1VA;AAAA;AAAA;;;;;;;;;;AL8VA;AAAA;AAAA;AACA;;;;;;;;;;;AK1VA;AAAA;AAAA;AACA;;;;;;;;;;AL4VA;AAAA;AAAA;AAAA;;;;;;;;;;;AKrSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;ALySA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AKpSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ALwSA;AAAA;AAAA;AACA;;;;;;;;;;;AKpSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;ALsSA;AAAA;AAAA;AACA;;;;;;;;;;;AKjVA;AAAA;;AAAA;AAAA;;AACA;AAAA;AACA;;AAFA;AAAA;;;;;;;;;ALoVA;AAAA;AAAA;;;;;;;;;AK9UA;AAAA;;;;;;;;ALkVA;AAAA;AAAA;;;;;;;;;AK7UA;AAAA;AAAA;;;;;;;;;;ALiVA;AAAA;AAAA;AACA;;;;;;;;;;;AK7UA;AAAA;AAAA;AACA;;;;;;;;AL+UA;AAAA;AAAA;;;;;;;;;AK3UA;AAAA;AAAA;;;;;;;;;;AL+UA;AAAA;AAAA;AACA;;;;;;;;;;;AK3UA;AAAA;AAAA;AACA;;;;;;;;;;AL6UA;AAAA;AAAA;AAAA;;;;;;;;;;;AK1TA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;;;;;;;;;;;;AL8TA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AKznBA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;AL0nBA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;AAlqBA;;AAAA;AAAA;;;;;;;;;;AAsqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAKA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;AEzfA;;;;;;;;AF6fA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;AEvfA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AFyfA;AAAA;AAAA;AACA;;;;;;;;;;;AEpfA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;AFqfA;AAAA;AACA;;;;;;;;;AEjfA;AACA;AAAA;AACA;;;;;;;;AFkfA;AAAA;AAAA;;;;;;;;;AE7eA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AFifA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AE5eA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AFgfA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AE3eA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AF+eA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;;;AAKA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AMj9BA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;ANq8BA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;AAllCA;;AAAA;AAAA;;;;;;;;;;;;;;;;AAslCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;AE9nCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AFkoCA;AAAA;AACA;;;;;;;;;AEhoCA;AAAA;AAAA;AAAA;;;;;;;;;;;;AFmoCA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AEjoCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AFooCA;AAAA;AAAA;AACA;;;;;;;;;;;AEjnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AFmnCA;AAAA;AAAA;AACA;;;;;;;;;;;AE/mCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AFinCA;AAAA;AAAA;AACA;;;;;;;;;;;AE7mCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AF+mCA;AAAA;AAAA;;;;;;;;;AE1mCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AF8mCA;AAAA;AAAA;;;;;;;;;AEvmCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AF2mCA;AAAA;AAAA;;;;;;;;;;AErmCA;AAAA;AACA;AAAA;;AAEA;AAOA;AAAA;;AALA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;;;;;;;;;AF+lCA;AAAA;AAAA;;;;;;;;;AE1lCA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AF8lCA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AEzlCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AF6lCA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;AE1mCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AF8mCA;AAAA;AACA;;;;;;;;;AE5mCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AF+mCA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AE7mCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AFgnCA;AAAA;AAAA;AACA;;;;;;;;;;;;AEzmCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AF2mCA;AAAA;AAAA;AACA;;;;;;;;;;;;AEvmCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AFymCA;AAAA;AAAA;AACA;;;;;;;;;;;AErmCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AFumCA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AOppCA;AAAA;AAAA;AAAA;;;;;;;;APwpCA;AAAA;AAAA;;;;;;;;;;;AO1jCA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;AP2jCA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;AOrpCA;AAAA;AAAA;AAAA;;;;;;;;;APypCA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;AOppCA;AAAA;AAAA;AAAA;;;;;;;;APwpCA;AAAA;AAAA;;;;;;;;;AOlpCA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;APopCA;AAAA;AAAA;AACA;;;;;;;;;;;;;AO/oCA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;APgpCA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AO5oCA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AP6oCA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AOxoCA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AACA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;APuoCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AKvzCA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;ALmzCA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AQz5CA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;ARs5CA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AO76CA;;;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;APi7CA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AO98CA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;APk9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AS1jDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;ATijDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AACA;;;;;;;;AAGA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AU5gDA;AAAA;AAAA;;;;;;;;AVghDA;AAAA;AAAA;;;;;;;;;AUtgDA;AAAA;AAAA;;;;;;;;AV0gDA;AAAA;AAAA;;;;;;;;;AUhgDA;AAAA;AAAA;AAAA;;;;;;;;;;;AVogDA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AUtpDA;AAAA;AAAA;AAAA;;;;;;;;;;;AV0pDA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AUxpDA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AV2pDA;AAAA;AAAA;;;;;;;;;AU1pDA;AAAA;AAAA;AAAA;;;;;;;;;;;AV8pDA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AU5pDA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AV+pDA;AAAA;AAAA;;;;;;;;;AU9pDA;AAAA;AAAA;AAAA;;;;;;;;;;;AVkqDA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AUhqDA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AVmqDA;AAAA;AAAA;;;;;;;;;AUlqDA;AAAA;AAAA;AAAA;;;;;;;;AVsqDA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AU9hDA;AAAA;AAAA;;;;;;;;AVkiDA;AAAA;AAAA;;;;;;;;;AU7hDA;AAAA;AAAA;;;;;;;;AViiDA;AAAA;AAAA;;;;;;;;;AU5hDA;AAAA;AAAA;AAAA;;;;;;;;AVgiDA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;;AUxiDA;AAAA;AAAA;AACA;;;;;;;;;AV0iDA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AUviDA;AAAA;AAAA;;;;;;;;AV2iDA;AAAA;AAAA;;;;;;;;;AUtiDA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AV0iDA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AUtiDA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAMA;;AAFA;AAAA;AAEA;;;;;;;;;AViiDA;AAAA;AAAA;;;;;;;;;AU5hDA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AVgiDA;AAAA;AAAA;;;;;;;;;AUthDA;AAAA;;;;;;;;AV0hDA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;ASnyDA;AAAA;;;;;;;;ATuyDA;AAAA;AAAA;;;;;;;;;ASpyDA;AAAA;;;;;;;;ATwyDA;AAAA;AAAA;;;;;;;;;ASryDA;AAAA;;;;;;;;ATyyDA;AAAA;AAAA;;;;;;;;;AStyDA;AAAA;AAAA;;;;;;;;AT0yDA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AS1vDA;AAAA;AAAA;;;;;;;;;;AT8vDA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;ASrzDA;AAAA;AAAA;;;;;;;;;;ATyzDA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;AA/+DA;;AAAA;AAAA;;;;;;;;;;AAm/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AEh5DA;AAAA;AAAA;AAAA;;;;;;;;;;AFo5DA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;AEj5DA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AFi5DA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;;AE94DA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AF84DA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AE14DA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AF24DA;AAAA;AACA;;;;;;;;;AEv4DA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AFw4DA;AAAA;AACA;;;;;;;;;AEp4DA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AFq4DA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;AEl4DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AF63DA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AEv3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AFk3DA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AWlmEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;AX2lEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;AYvrEA;;AACA;AADA;;AAAA;;;;AAEA;AAAA;AACA;AAAA;AACA;;AAAA;;;;AACA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;AZsrEA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AarxEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;AbixEA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AGr3EA;AAAA;AAAA;;;;;;;;AHy3EA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;Ach3EA;AAAA;AAAA;;;;;;;;Ado3EA;AAAA;AAAA;;;;;;;;;Acj3EA;AAAA;AAAA;;;;;;;;;;Adq3EA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;Aan7EA;AAAA;;;;;;;;Abu7EA;AAAA;AAAA;;;;;;;;;Aap7EA;AAAA;;;;;;;;;;Abw7EA;AAAA;AAAA;AACA;;;;;;;;;;;Aan7EA;AAAA;AAAA;AAAA;;;;;;;;Abs7EA;AAAA;AAAA;;;;;;;;;Aar7EA;AAAA;AAAA;;;;;;;;;;Aby7EA;AAAA;AAAA;AACA;;;;;;;;;;;Aav7EA;AAAA;AAAA;AAAA;;;;;;;;Ab07EA;AAAA;AAAA;;;;;;;;;Aaz7EA;AAAA;AAAA;;;;;;;;Ab67EA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;Ae5lFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AfqlFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AOnqFA;AAAA;;;;;;;;APuqFA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AEj7EA;AAAA;AAAA;AAAA;;;;;;;;;;AFq7EA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;AEl7EA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AFs7EA;AAAA;AACA;;;;;;;;;AEl7EA;AACA;AAAA;AACA;;;;;;;;;;;;AFm7EA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AE/6EA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AFg7EA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;AgBztFA;;AACA;AADA;;AAAA;;;;AAAA;;AAAA;;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;AhBqtFA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;AiBv5FA;;;;;;;;;;;;AjB25FA;AAAA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;;AiB15FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AjB85FA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AiB95FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AjBi6FA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AkBx5FA;AAAA;;;;;;;;AlB45FA;AAAA;AAAA;;;;;;;;;AkBz5FA;AAAA;;;;;;;;;;AlB65FA;AAAA;AAAA;AACA;;;;;;;;;;;AkB35FA;AAAA;AAAA;AAAA;;;;;;;;AlB85FA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;AmBh/FA;;AACA;AADA;;AAAA;;;;;AAAA;AAAA;;;;AAAA;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;AAAA;;;;;;AAAA;AAAA;;;;;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAAA;;;;AACA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;AnB8+FA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AmB/gGA;AAAA;AAAA;;;;;;;;;;AnBmhGA;AAAA;AAAA;AAAA;;;;;;;;;;;AmB1/FA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;;;;;;;;;;AnB8/FA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;AoB/lGA;;AACA;AADA;;AAAA;;;;AAAA;;AAAA;;;;AAAA;;AAAA;;;;AAAA;;AAAA;;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;ApBylGA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;AA3pGA;;AAAA;AAAA;;;;;;;;;;;;AA+pGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AqB5uGA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;ArBouGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;AAAA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AArxGA;;AAAA;AAAA;;;;;;;;;;;;;;AAyxGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AWx1GA;AAAA;;;;;;;;AX41GA;AAAA;AAAA;;;;;;;;;AWz1GA;AAAA;;;;;;;;AX61GA;AAAA;AAAA;;;;;;;;;AW11GA;AAAA;;;;;;;;AX81GA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AW1xGA;AAAA;AAAA;;;;;;;;;;AX8xGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AW7xGA;AAAA;AAAA;;;;;;;;;;AXiyGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;;AWjyGA;AAAA;AAAA;AACA;;;;;;;;AXmyGA;AAAA;AAAA;;;;;;;;;AW/xGA;AAAA;AAAA;;;;;;;;;;AXmyGA;AAAA;AAAA;AACA;;;;;;;;;;;AW/xGA;AAAA;AAAA;AACA;;;;;;;;AXiyGA;AAAA;AAAA;;;;;;;;;AW7xGA;AAAA;AAAA;;;;;;;;AXiyGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAKA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AsBrmHA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;AtBkmHA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AuBn/GA;AAAA;;;;;;;;;;AvBu/GA;AAAA;AAAA;AACA;;;;;;;;;;;;AuB9+GA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AvB2+GA;AAAA;AAAA;;;;;;;;;AuBt9GA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AvB09GA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AuB5+GA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAMA;;AAFA;AAAA;AAEA;;;;;;;;;AvBu+GA;AAAA;AAAA;;;;;;;;;AuBn+GA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AvBu+GA;AAAA;AAAA;;;;;;;;;AuB79GA;AAAA;AAAA;;;;;;;;AvBi+GA;AAAA;AAAA;;;;;;;;;AuBv9GA;AAAA;AAAA;;;;;;;;AvB29GA;AAAA;AAAA;;;;;;;;;AuB58GA;AAAA;AAAA;;;;;;;;AvBg9GA;AAAA;AAAA;;;;;;;;;AuBr9GA;AAAA;AAAA;;;;;;;;AvBy9GA;AAAA;AAAA;;;;;;;;;AuB18GA;AAAA;AAAA;;;;;;;;;;AvB88GA;AAAA;AAAA;AACA;;;;;;;;;;;AuBr8GA;AAAA;AAAA;AACA;;;;;;;;AvBu8GA;AAAA;AAAA;;;;;;;;;AuBn8GA;AAAA;AAAA;;;;;;;;AvBu8GA;AAAA;AACA;;;;;;;;;AuBn8GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AvBq8GA;AAAA;AAAA;AACA;;;;;;;;;;;AuBl8GA;AAAA;AAAA;AACA;;;;;;;;AvBo8GA;AAAA;AAAA;;;;;;;;;AuBh8GA;AAAA;AAAA;;;;;;;;AvBo8GA;AAAA;AACA;;;;;;;;;AuBh8GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AvBk8GA;AAAA;AAAA;AACA;;;;;;;;;;;AuB/7GA;AAAA;AAAA;AACA;;;;;;;;AvBi8GA;AAAA;AAAA;;;;;;;;;AuB77GA;AAAA;AAAA;;;;;;AvBm8GA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AI7vHA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;AJyvHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AM/6GA;AAAA;;;;;;;;ANm7GA;AAAA;AAAA;;;;;;;;;AM96GA;AAAA;;;;;;;;ANk7GA;AAAA;AAAA;;;;;;;;;AM76GA;AAAA;AAAA;AAAA;;;;;;;;ANi7GA;AAAA;AAAA;;;;;;;;;AM56GA;AAAA;AAAA;;;;;;;;ANg7GA;AAAA;AAAA;;;;;;;;;AM36GA;AAAA;;;;;;;;;;AN+6GA;AAAA;AAAA;AACA;;;;;;;;;;;AM36GA;AAAA;;AAWA;;AANA;AAAA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AACA;;;;;;;;ANm6GA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;AMh6GA;AAAA;;;;;;;;;;ANo6GA;AAAA;AAAA;AACA;;;;;;;;;;;AMh6GA;AAAA;;AAWA;;AANA;AAAA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AACA;;;;;;;;ANw5GA;AAAA;AAAA;;;;;;;;;AMp5GA;AAAA;AAAA;;;;;;;;;;;;;;;ANw5GA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AM9sGA;AAAA;;AAgBA;;AAXA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAKA;;AAHA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;ANisGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AM9rGA;AAAA;;AAeA;;AAVA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAIA;;AAFA;AAAA;AAAA;AAEA;;;;;;;;;;;;;ANkrGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AM/qGA;AAAA;;AAeA;;AAVA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAIA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;ANmqGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AMhqGA;AAAA;;AAgBA;;AAXA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAKA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;ANmpGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AMhpGA;AAAA;;AAeA;;AAVA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAIA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;ANooGA;AAAA;AAAA;;;;;;;;;AMv6GA;AAAA;AAAA;;;;;;;;AN26GA;AAAA;AAAA;;;;;;;;;AMt6GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AN06GA;AAAA;AAAA;AACA;;;;;;;;;;;;AMt6GA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;ANs6GA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AACA;;;;;;;;;;;AAGA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AM36GA;AAAA;AAAA;AAAA;;;;;;;;;;;AN+6GA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AM36GA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AN+6GA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AM36GA;AAAA;AAAA;AAAA;;;;;;;;;;;AN+6GA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AM36GA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AN+6GA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AM36GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AN+6GA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AM36GA;AAAA;AAAA;AAAA;;;;;;;;AN+6GA;AAAA;AAAA;;;;;;;;;AM16GA;AAAA;AAAA;;;;;;;;;;AN86GA;AAAA;AAAA;AACA;;;;;;;;;;;AM16GA;AAAA;AAAA;AACA;;;;;;;;AN46GA;AAAA;AAAA;;;;;;;;;AMx6GA;AAAA;AAAA;;;;;;;;;;AN46GA;AAAA;AAAA;AACA;;;;;;;;;;;AMx6GA;AAAA;AAAA;AACA;;;;;;;;AN06GA;AAAA;AAAA;;;;;;;;;AMt6GA;AAAA;AAAA;;;;;;;;;;AN06GA;AAAA;AAAA;AACA;;;;;;;;;;;AMt6GA;AAAA;AAAA;AACA;;;;;;;;;;ANw6GA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AM3jHA;AAAA;;;;;;;;;;;AN+jHA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AM76GA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAMA;;AAFA;AAAA;AAAA;AAEA;;;;;;;;;ANw6GA;AAAA;AAAA;;;;;;;;;AMp6GA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ANw6GA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AMh4GA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAOA;;AAHA;AAAA;AAAA;AACA;AAEA;;;;;;;;;AN03GA;AAAA;AAAA;;;;;;;;;AMt3GA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AN03GA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AM56GA;AAAA;AAEA;AAAA;AAAA;;AAQA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;;AAfA;AAAA;;AAeA;;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAYA;;;;;;;;AN85GA;AAAA;AAAA;;;;;;;;;AM15GA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AN85GA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AM75GA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ANi6GA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AMh6GA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;ANo6GA;AAAA;AAAA;;;;;;;;;AM74GA;AAAA;AAAA;;;;;;;;ANi5GA;AAAA;AAAA;;;;;;;;;AMv4GA;AAAA;AAAA;;;;;;;;AN24GA;AAAA;AAAA;;;;;;;;;AMj4GA;AAAA;AAAA;;;;;;;;ANq4GA;AAAA;AAAA;;;;;;;;;AM33GA;AAAA;AAAA;;;;;;;;AN+3GA;AAAA;AAAA;;;;;;;;;AMh3GA;AAAA;AAAA;;;;;;;;;;ANo3GA;AAAA;AAAA;AACA;;;;;;;;;;;AM13GA;AAAA;AAAA;AACA;;;;;;;;AN43GA;AAAA;AAAA;;;;;;;;;AMlwGA;AAAA;AAAA;;;;;;;;ANswGA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AQ/hIA;AAAA;;;;;;;;ARmiIA;AAAA;AAAA;;;;;;;;;AQhiIA;AAAA;;;;;;;;;;ARoiIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;Ac3pIA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;AdypIA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;AqBhqIA;AAAA;;;;;;;;ArBoqIA;AAAA;AAAA;;;;;;;;;AqBjqIA;AAAA;;;;;;;;ArBqqIA;AAAA;AAAA;;;;;;;;;AqBlqIA;AAAA;AAAA;;;;;;;;ArBsqIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AqB5mIA;AAAA;AAAA;;;;;;;;;;ArBgnIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;AqBjrIA;AAAA;AAAA;;;;;;;;;;ArBqrIA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;AAEA;AAAA;AAFA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;AAIA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AkB14IA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;AlBw4IA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;;AAKA;;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;AwBv9IA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;AxBm9IA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAGA;AAAA;;AAAA;;AACA;;;;;AAIA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAGA;;;;;AAKA;;;;;AAGA;;;;;;;;;AyBnrJA;;AAAA;AAAA;;;;;;;;;AzBPA;AAAA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;AyBeA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AzBjBA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;A0BiBA;AAAA;;;;;;;;;ADvBA;AAAA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;AC0BA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;AxBXA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AwB8FA;AAAA;;;;;;;;;A1B9FA;AAAA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;A0B8FA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;AASA;AAAA;;;;;;;;;A1BxFA;AAAA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;A0BwFA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;AxB4TA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA+LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AwBpjBA;AAAA;;;;;;;;;A1BhBA;AAAA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;A0BVA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;AAGA;;;;;;;;;;AAGA;;;;;;;;;;;;AAgBA;;;;;;;;;;;;AAYA;;;;;;;;;;AvB5EA;AAAA;;;;;;;;;;;;;;;;AAaA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;AuBHA;AAAA;;;;;;;;;A1BoDA;AAAA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;A0BpDA;;;;;;;;;A1BmEA;AAAA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAKA;;;;;;;;AiB7HA;;;;;;;;;;AMDA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ArB0WA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAqKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAlBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAlJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["\n#include <emscripten.h>\n\nclass JSDestructionListener : public b2DestructionListenerWrapper {\npublic:\n  void SayGoodbyeJoint(b2Joint* arg0) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDestructionListener'])[$0];\n      if (!self.hasOwnProperty('SayGoodbyeJoint')) throw 'a JSImplementation must implement all functions, you forgot JSDestructionListener::SayGoodbyeJoint.';\n      self['SayGoodbyeJoint']($1);\n    }, (int)this, (int)arg0);\n  }\n  void SayGoodbyeFixture(b2Fixture* arg0) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDestructionListener'])[$0];\n      if (!self.hasOwnProperty('SayGoodbyeFixture')) throw 'a JSImplementation must implement all functions, you forgot JSDestructionListener::SayGoodbyeFixture.';\n      self['SayGoodbyeFixture']($1);\n    }, (int)this, (int)arg0);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDestructionListener'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSDestructionListener::__destroy__.';\n      self['__destroy__']();\n    }, (int)this);\n  }\n};\n\nclass JSQueryCallback : public b2QueryCallback {\npublic:\n  bool ReportFixture(b2Fixture* arg0) {\n    return EM_ASM_INT({\n      var self = Module['getCache'](Module['JSQueryCallback'])[$0];\n      if (!self.hasOwnProperty('ReportFixture')) throw 'a JSImplementation must implement all functions, you forgot JSQueryCallback::ReportFixture.';\n      return self['ReportFixture']($1);\n    }, (int)this, (int)arg0);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSQueryCallback'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSQueryCallback::__destroy__.';\n      self['__destroy__']();\n    }, (int)this);\n  }\n};\n\nclass JSRayCastCallback : public b2RayCastCallback {\npublic:\n  float ReportFixture(b2Fixture* arg0, const b2Vec2& arg1, const b2Vec2& arg2, float arg3) {\n    return EM_ASM_DOUBLE({\n      var self = Module['getCache'](Module['JSRayCastCallback'])[$0];\n      if (!self.hasOwnProperty('ReportFixture')) throw 'a JSImplementation must implement all functions, you forgot JSRayCastCallback::ReportFixture.';\n      return self['ReportFixture']($1,$2,$3,$4);\n    }, (int)this, (int)arg0, (int)&arg1, (int)&arg2, arg3);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSRayCastCallback'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSRayCastCallback::__destroy__.';\n      self['__destroy__']();\n    }, (int)this);\n  }\n};\n\nclass JSContactListener : public b2ContactListener {\npublic:\n  void BeginContact(b2Contact* arg0) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactListener'])[$0];\n      if (!self.hasOwnProperty('BeginContact')) throw 'a JSImplementation must implement all functions, you forgot JSContactListener::BeginContact.';\n      self['BeginContact']($1);\n    }, (int)this, (int)arg0);\n  }\n  void EndContact(b2Contact* arg0) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactListener'])[$0];\n      if (!self.hasOwnProperty('EndContact')) throw 'a JSImplementation must implement all functions, you forgot JSContactListener::EndContact.';\n      self['EndContact']($1);\n    }, (int)this, (int)arg0);\n  }\n  void PreSolve(b2Contact* arg0, const b2Manifold* arg1) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactListener'])[$0];\n      if (!self.hasOwnProperty('PreSolve')) throw 'a JSImplementation must implement all functions, you forgot JSContactListener::PreSolve.';\n      self['PreSolve']($1,$2);\n    }, (int)this, (int)arg0, (int)arg1);\n  }\n  void PostSolve(b2Contact* arg0, const b2ContactImpulse* arg1) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactListener'])[$0];\n      if (!self.hasOwnProperty('PostSolve')) throw 'a JSImplementation must implement all functions, you forgot JSContactListener::PostSolve.';\n      self['PostSolve']($1,$2);\n    }, (int)this, (int)arg0, (int)arg1);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactListener'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSContactListener::__destroy__.';\n      self['__destroy__']();\n    }, (int)this);\n  }\n};\n\nclass JSContactFilter : public b2ContactFilter {\npublic:\n  bool ShouldCollide(b2Fixture* arg0, b2Fixture* arg1) {\n    return EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactFilter'])[$0];\n      if (!self.hasOwnProperty('ShouldCollide')) throw 'a JSImplementation must implement all functions, you forgot JSContactFilter::ShouldCollide.';\n      return self['ShouldCollide']($1,$2);\n    }, (int)this, (int)arg0, (int)arg1);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSContactFilter'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSContactFilter::__destroy__.';\n      self['__destroy__']();\n    }, (int)this);\n  }\n};\n\nclass JSDraw : public b2Draw {\npublic:\n  void DrawPolygon(const b2Vec2* arg0, int arg1, const b2Color& arg2) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawPolygon')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawPolygon.';\n      self['DrawPolygon']($1,$2,$3);\n    }, (int)this, (int)arg0, arg1, (int)&arg2);\n  }\n  void DrawSolidPolygon(const b2Vec2* arg0, int arg1, const b2Color& arg2) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawSolidPolygon')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawSolidPolygon.';\n      self['DrawSolidPolygon']($1,$2,$3);\n    }, (int)this, (int)arg0, arg1, (int)&arg2);\n  }\n  void DrawCircle(const b2Vec2& arg0, float arg1, const b2Color& arg2) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawCircle')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawCircle.';\n      self['DrawCircle']($1,$2,$3);\n    }, (int)this, (int)&arg0, arg1, (int)&arg2);\n  }\n  void DrawSolidCircle(const b2Vec2& arg0, float arg1, const b2Vec2& arg2, const b2Color& arg3) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawSolidCircle')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawSolidCircle.';\n      self['DrawSolidCircle']($1,$2,$3,$4);\n    }, (int)this, (int)&arg0, arg1, (int)&arg2, (int)&arg3);\n  }\n  void DrawSegment(const b2Vec2& arg0, const b2Vec2& arg1, const b2Color& arg2) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawSegment')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawSegment.';\n      self['DrawSegment']($1,$2,$3);\n    }, (int)this, (int)&arg0, (int)&arg1, (int)&arg2);\n  }\n  void DrawTransform(const b2Transform& arg0) {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('DrawTransform')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::DrawTransform.';\n      self['DrawTransform']($1);\n    }, (int)this, (int)&arg0);\n  }\n  void __destroy__() {\n    EM_ASM_INT({\n      var self = Module['getCache'](Module['JSDraw'])[$0];\n      if (!self.hasOwnProperty('__destroy__')) throw 'a JSImplementation must implement all functions, you forgot JSDraw::__destroy__.';\n      self['__destroy__']();\n    }, (int)this);\n  }\n};\n\nextern \"C\" {\n\n// Not using size_t for array indices as the values used by the javascript code are signed.\nvoid array_bounds_check(const int array_size, const int array_idx) {\n  if (array_idx < 0 || array_idx >= array_size) {\n    EM_ASM_INT({\n      throw 'Array index ' + $0 + ' out of bounds: [0,' + $1 + ')';\n    }, array_idx, array_size);\n  }\n}\n\n// b2DestructionListenerWrapper\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DestructionListenerWrapper___destroy___0(b2DestructionListenerWrapper* self) {\n  delete self;\n}\n\n// b2Draw\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Draw_SetFlags_1(b2Draw* self, unsigned int arg0) {\n  self->SetFlags(arg0);\n}\n\nunsigned int EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Draw_GetFlags_0(b2Draw* self) {\n  return self->GetFlags();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Draw_AppendFlags_1(b2Draw* self, unsigned int arg0) {\n  self->AppendFlags(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Draw_ClearFlags_1(b2Draw* self, unsigned int arg0) {\n  self->ClearFlags(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Draw___destroy___0(b2Draw* self) {\n  delete self;\n}\n\n// b2Joint\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetType_0(b2Joint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetBodyA_0(b2Joint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetBodyB_0(b2Joint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetAnchorA_0(b2Joint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetAnchorB_0(b2Joint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetReactionForce_1(b2Joint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetReactionTorque_1(b2Joint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetNext_0(b2Joint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetUserData_0(b2Joint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_SetUserData_1(b2Joint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_IsActive_0(b2Joint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_GetCollideConnected_0(b2Joint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Joint_Dump_0(b2Joint* self) {\n  self->Dump();\n}\n\n// b2RayCastCallback\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastCallback___destroy___0(b2RayCastCallback* self) {\n  delete self;\n}\n\n// b2ContactListener\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactListener___destroy___0(b2ContactListener* self) {\n  delete self;\n}\n\n// b2QueryCallback\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2QueryCallback___destroy___0(b2QueryCallback* self) {\n  delete self;\n}\n\n// b2JointDef\n\nb2JointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_b2JointDef_0() {\n  return new b2JointDef();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_get_type_0(b2JointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_set_type_1(b2JointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_get_userData_0(b2JointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_set_userData_1(b2JointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_get_bodyA_0(b2JointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_set_bodyA_1(b2JointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_get_bodyB_0(b2JointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_set_bodyB_1(b2JointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_get_collideConnected_0(b2JointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef_set_collideConnected_1(b2JointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointDef___destroy___0(b2JointDef* self) {\n  delete self;\n}\n\n// b2Shape\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_GetType_0(b2Shape* self) {\n  return self->GetType();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_GetChildCount_0(b2Shape* self) {\n  return self->GetChildCount();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_TestPoint_2(b2Shape* self, b2Transform* arg0, b2Vec2* arg1) {\n  return self->TestPoint(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_RayCast_4(b2Shape* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, b2Transform* arg2, int arg3) {\n  return self->RayCast(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_ComputeAABB_3(b2Shape* self, b2AABB* arg0, b2Transform* arg1, int arg2) {\n  self->ComputeAABB(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_ComputeMass_2(b2Shape* self, b2MassData* arg0, float arg1) {\n  self->ComputeMass(arg0, arg1);\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_get_m_type_0(b2Shape* self) {\n  return self->m_type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_set_m_type_1(b2Shape* self, b2ShapeType arg0) {\n  self->m_type = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_get_m_radius_0(b2Shape* self) {\n  return self->m_radius;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape_set_m_radius_1(b2Shape* self, float arg0) {\n  self->m_radius = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Shape___destroy___0(b2Shape* self) {\n  delete self;\n}\n\n// b2ContactFilter\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFilter___destroy___0(b2ContactFilter* self) {\n  delete self;\n}\n\n// JSDestructionListener\n\nJSDestructionListener* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDestructionListener_JSDestructionListener_0() {\n  return new JSDestructionListener();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDestructionListener_SayGoodbyeJoint_1(JSDestructionListener* self, b2Joint* arg0) {\n  self->SayGoodbyeJoint(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDestructionListener_SayGoodbyeFixture_1(JSDestructionListener* self, b2Fixture* arg0) {\n  self->SayGoodbyeFixture(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDestructionListener___destroy___0(JSDestructionListener* self) {\n  delete self;\n}\n\n// b2ContactImpulse\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactImpulse_get_count_0(b2ContactImpulse* self) {\n  return self->count;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactImpulse_set_count_1(b2ContactImpulse* self, int arg0) {\n  self->count = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactImpulse___destroy___0(b2ContactImpulse* self) {\n  delete self;\n}\n\n// b2DistanceJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetLocalAnchorA_0(b2DistanceJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetLocalAnchorB_0(b2DistanceJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_SetLength_1(b2DistanceJoint* self, float arg0) {\n  self->SetLength(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetLength_0(b2DistanceJoint* self) {\n  return self->GetLength();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_SetFrequency_1(b2DistanceJoint* self, float arg0) {\n  self->SetFrequency(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetFrequency_0(b2DistanceJoint* self) {\n  return self->GetFrequency();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_SetDampingRatio_1(b2DistanceJoint* self, float arg0) {\n  self->SetDampingRatio(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetDampingRatio_0(b2DistanceJoint* self) {\n  return self->GetDampingRatio();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetType_0(b2DistanceJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetBodyA_0(b2DistanceJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetBodyB_0(b2DistanceJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetAnchorA_0(b2DistanceJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetAnchorB_0(b2DistanceJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetReactionForce_1(b2DistanceJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetReactionTorque_1(b2DistanceJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetNext_0(b2DistanceJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetUserData_0(b2DistanceJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_SetUserData_1(b2DistanceJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_IsActive_0(b2DistanceJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint_GetCollideConnected_0(b2DistanceJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJoint___destroy___0(b2DistanceJoint* self) {\n  delete self;\n}\n\n// b2Mat33\n\nb2Mat33* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_b2Mat33_0() {\n  return new b2Mat33();\n}\n\nb2Mat33* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_b2Mat33_3(b2Vec3* arg0, b2Vec3* arg1, b2Vec3* arg2) {\n  return new b2Mat33(*arg0, *arg1, *arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_SetZero_0(b2Mat33* self) {\n  self->SetZero();\n}\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_Solve33_1(b2Mat33* self, b2Vec3* arg0) {\n  static b2Vec3 temp;\n  return (temp = self->Solve33(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_Solve22_1(b2Mat33* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->Solve22(*arg0), &temp);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_GetInverse22_1(b2Mat33* self, b2Mat33* arg0) {\n  self->GetInverse22(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_GetSymInverse33_1(b2Mat33* self, b2Mat33* arg0) {\n  self->GetSymInverse33(arg0);\n}\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_get_ex_0(b2Mat33* self) {\n  return &self->ex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_set_ex_1(b2Mat33* self, b2Vec3* arg0) {\n  self->ex = *arg0;\n}\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_get_ey_0(b2Mat33* self) {\n  return &self->ey;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_set_ey_1(b2Mat33* self, b2Vec3* arg0) {\n  self->ey = *arg0;\n}\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_get_ez_0(b2Mat33* self) {\n  return &self->ez;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33_set_ez_1(b2Mat33* self, b2Vec3* arg0) {\n  self->ez = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat33___destroy___0(b2Mat33* self) {\n  delete self;\n}\n\n// b2Fixture\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetType_0(b2Fixture* self) {\n  return self->GetType();\n}\n\nb2Shape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetShape_0(b2Fixture* self) {\n  return self->GetShape();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetSensor_1(b2Fixture* self, bool arg0) {\n  self->SetSensor(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_IsSensor_0(b2Fixture* self) {\n  return self->IsSensor();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetFilterData_1(b2Fixture* self, b2Filter* arg0) {\n  self->SetFilterData(*arg0);\n}\n\nconst b2Filter* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetFilterData_0(b2Fixture* self) {\n  return &self->GetFilterData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_Refilter_0(b2Fixture* self) {\n  self->Refilter();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetBody_0(b2Fixture* self) {\n  return self->GetBody();\n}\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetNext_0(b2Fixture* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetUserData_0(b2Fixture* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetUserData_1(b2Fixture* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_TestPoint_1(b2Fixture* self, b2Vec2* arg0) {\n  return self->TestPoint(*arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_RayCast_3(b2Fixture* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, int arg2) {\n  return self->RayCast(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetMassData_1(b2Fixture* self, b2MassData* arg0) {\n  self->GetMassData(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetDensity_1(b2Fixture* self, float arg0) {\n  self->SetDensity(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetDensity_0(b2Fixture* self) {\n  return self->GetDensity();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetFriction_0(b2Fixture* self) {\n  return self->GetFriction();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetFriction_1(b2Fixture* self, float arg0) {\n  self->SetFriction(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetRestitution_0(b2Fixture* self) {\n  return self->GetRestitution();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_SetRestitution_1(b2Fixture* self, float arg0) {\n  self->SetRestitution(arg0);\n}\n\nconst b2AABB* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_GetAABB_1(b2Fixture* self, int arg0) {\n  return &self->GetAABB(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture_Dump_1(b2Fixture* self, int arg0) {\n  self->Dump(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Fixture___destroy___0(b2Fixture* self) {\n  delete self;\n}\n\n// b2Filter\n\nb2Filter* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_b2Filter_0() {\n  return new b2Filter();\n}\n\nunsigned short EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_get_categoryBits_0(b2Filter* self) {\n  return self->categoryBits;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_set_categoryBits_1(b2Filter* self, unsigned short arg0) {\n  self->categoryBits = arg0;\n}\n\nunsigned short EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_get_maskBits_0(b2Filter* self) {\n  return self->maskBits;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_set_maskBits_1(b2Filter* self, unsigned short arg0) {\n  self->maskBits = arg0;\n}\n\nshort EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_get_groupIndex_0(b2Filter* self) {\n  return self->groupIndex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter_set_groupIndex_1(b2Filter* self, short arg0) {\n  self->groupIndex = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Filter___destroy___0(b2Filter* self) {\n  delete self;\n}\n\n// JSQueryCallback\n\nJSQueryCallback* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSQueryCallback_JSQueryCallback_0() {\n  return new JSQueryCallback();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_JSQueryCallback_ReportFixture_1(JSQueryCallback* self, b2Fixture* arg0) {\n  return self->ReportFixture(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSQueryCallback___destroy___0(JSQueryCallback* self) {\n  delete self;\n}\n\n// b2MouseJoint\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_SetTarget_1(b2MouseJoint* self, b2Vec2* arg0) {\n  self->SetTarget(*arg0);\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetTarget_0(b2MouseJoint* self) {\n  return &self->GetTarget();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_SetMaxForce_1(b2MouseJoint* self, float arg0) {\n  self->SetMaxForce(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetMaxForce_0(b2MouseJoint* self) {\n  return self->GetMaxForce();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_SetFrequency_1(b2MouseJoint* self, float arg0) {\n  self->SetFrequency(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetFrequency_0(b2MouseJoint* self) {\n  return self->GetFrequency();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_SetDampingRatio_1(b2MouseJoint* self, float arg0) {\n  self->SetDampingRatio(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetDampingRatio_0(b2MouseJoint* self) {\n  return self->GetDampingRatio();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetType_0(b2MouseJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetBodyA_0(b2MouseJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetBodyB_0(b2MouseJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetAnchorA_0(b2MouseJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetAnchorB_0(b2MouseJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetReactionForce_1(b2MouseJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetReactionTorque_1(b2MouseJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetNext_0(b2MouseJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetUserData_0(b2MouseJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_SetUserData_1(b2MouseJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_IsActive_0(b2MouseJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint_GetCollideConnected_0(b2MouseJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJoint___destroy___0(b2MouseJoint* self) {\n  delete self;\n}\n\n// b2Rot\n\nb2Rot* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_b2Rot_0() {\n  return new b2Rot();\n}\n\nb2Rot* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_b2Rot_1(float arg0) {\n  return new b2Rot(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_Set_1(b2Rot* self, float arg0) {\n  self->Set(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_SetIdentity_0(b2Rot* self) {\n  self->SetIdentity();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_GetAngle_0(b2Rot* self) {\n  return self->GetAngle();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_GetXAxis_0(b2Rot* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetXAxis(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_GetYAxis_0(b2Rot* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetYAxis(), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_get_s_0(b2Rot* self) {\n  return self->s;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_set_s_1(b2Rot* self, float arg0) {\n  self->s = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_get_c_0(b2Rot* self) {\n  return self->c;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot_set_c_1(b2Rot* self, float arg0) {\n  self->c = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Rot___destroy___0(b2Rot* self) {\n  delete self;\n}\n\n// b2MotorJoint\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_SetLinearOffset_1(b2MotorJoint* self, b2Vec2* arg0) {\n  self->SetLinearOffset(*arg0);\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetLinearOffset_0(b2MotorJoint* self) {\n  return &self->GetLinearOffset();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_SetAngularOffset_1(b2MotorJoint* self, float arg0) {\n  self->SetAngularOffset(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetAngularOffset_0(b2MotorJoint* self) {\n  return self->GetAngularOffset();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_SetMaxForce_1(b2MotorJoint* self, float arg0) {\n  self->SetMaxForce(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetMaxForce_0(b2MotorJoint* self) {\n  return self->GetMaxForce();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_SetMaxTorque_1(b2MotorJoint* self, float arg0) {\n  self->SetMaxTorque(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetMaxTorque_0(b2MotorJoint* self) {\n  return self->GetMaxTorque();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_SetCorrectionFactor_1(b2MotorJoint* self, float arg0) {\n  self->SetCorrectionFactor(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetCorrectionFactor_0(b2MotorJoint* self) {\n  return self->GetCorrectionFactor();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetType_0(b2MotorJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetBodyA_0(b2MotorJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetBodyB_0(b2MotorJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetAnchorA_0(b2MotorJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetAnchorB_0(b2MotorJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetReactionForce_1(b2MotorJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetReactionTorque_1(b2MotorJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetNext_0(b2MotorJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetUserData_0(b2MotorJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_SetUserData_1(b2MotorJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_IsActive_0(b2MotorJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint_GetCollideConnected_0(b2MotorJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJoint___destroy___0(b2MotorJoint* self) {\n  delete self;\n}\n\n// b2Profile\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_step_0(b2Profile* self) {\n  return self->step;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_step_1(b2Profile* self, float arg0) {\n  self->step = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_collide_0(b2Profile* self) {\n  return self->collide;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_collide_1(b2Profile* self, float arg0) {\n  self->collide = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_solve_0(b2Profile* self) {\n  return self->solve;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_solve_1(b2Profile* self, float arg0) {\n  self->solve = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_solveInit_0(b2Profile* self) {\n  return self->solveInit;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_solveInit_1(b2Profile* self, float arg0) {\n  self->solveInit = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_solveVelocity_0(b2Profile* self) {\n  return self->solveVelocity;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_solveVelocity_1(b2Profile* self, float arg0) {\n  self->solveVelocity = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_solvePosition_0(b2Profile* self) {\n  return self->solvePosition;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_solvePosition_1(b2Profile* self, float arg0) {\n  self->solvePosition = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_broadphase_0(b2Profile* self) {\n  return self->broadphase;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_broadphase_1(b2Profile* self, float arg0) {\n  self->broadphase = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_get_solveTOI_0(b2Profile* self) {\n  return self->solveTOI;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile_set_solveTOI_1(b2Profile* self, float arg0) {\n  self->solveTOI = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Profile___destroy___0(b2Profile* self) {\n  delete self;\n}\n\n// VoidPtr\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_VoidPtr___destroy___0(void** self) {\n  delete self;\n}\n\n// b2BodyDef\n\nb2BodyDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_b2BodyDef_0() {\n  return new b2BodyDef();\n}\n\nb2BodyType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_type_0(b2BodyDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_type_1(b2BodyDef* self, b2BodyType arg0) {\n  self->type = arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_position_0(b2BodyDef* self) {\n  return &self->position;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_position_1(b2BodyDef* self, b2Vec2* arg0) {\n  self->position = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_angle_0(b2BodyDef* self) {\n  return self->angle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_angle_1(b2BodyDef* self, float arg0) {\n  self->angle = arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_linearVelocity_0(b2BodyDef* self) {\n  return &self->linearVelocity;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_linearVelocity_1(b2BodyDef* self, b2Vec2* arg0) {\n  self->linearVelocity = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_angularVelocity_0(b2BodyDef* self) {\n  return self->angularVelocity;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_angularVelocity_1(b2BodyDef* self, float arg0) {\n  self->angularVelocity = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_linearDamping_0(b2BodyDef* self) {\n  return self->linearDamping;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_linearDamping_1(b2BodyDef* self, float arg0) {\n  self->linearDamping = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_angularDamping_0(b2BodyDef* self) {\n  return self->angularDamping;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_angularDamping_1(b2BodyDef* self, float arg0) {\n  self->angularDamping = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_allowSleep_0(b2BodyDef* self) {\n  return self->allowSleep;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_allowSleep_1(b2BodyDef* self, bool arg0) {\n  self->allowSleep = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_awake_0(b2BodyDef* self) {\n  return self->awake;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_awake_1(b2BodyDef* self, bool arg0) {\n  self->awake = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_fixedRotation_0(b2BodyDef* self) {\n  return self->fixedRotation;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_fixedRotation_1(b2BodyDef* self, bool arg0) {\n  self->fixedRotation = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_bullet_0(b2BodyDef* self) {\n  return self->bullet;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_bullet_1(b2BodyDef* self, bool arg0) {\n  self->bullet = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_active_0(b2BodyDef* self) {\n  return self->active;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_active_1(b2BodyDef* self, bool arg0) {\n  self->active = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_userData_0(b2BodyDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_userData_1(b2BodyDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_get_gravityScale_0(b2BodyDef* self) {\n  return self->gravityScale;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef_set_gravityScale_1(b2BodyDef* self, float arg0) {\n  self->gravityScale = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2BodyDef___destroy___0(b2BodyDef* self) {\n  delete self;\n}\n\n// JSRayCastCallback\n\nJSRayCastCallback* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSRayCastCallback_JSRayCastCallback_0() {\n  return new JSRayCastCallback();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_JSRayCastCallback_ReportFixture_4(JSRayCastCallback* self, b2Fixture* arg0, b2Vec2* arg1, b2Vec2* arg2, float arg3) {\n  return self->ReportFixture(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSRayCastCallback___destroy___0(JSRayCastCallback* self) {\n  delete self;\n}\n\n// b2ContactFeature\n\nunsigned char EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_get_indexA_0(b2ContactFeature* self) {\n  return self->indexA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_set_indexA_1(b2ContactFeature* self, unsigned char arg0) {\n  self->indexA = arg0;\n}\n\nunsigned char EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_get_indexB_0(b2ContactFeature* self) {\n  return self->indexB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_set_indexB_1(b2ContactFeature* self, unsigned char arg0) {\n  self->indexB = arg0;\n}\n\nunsigned char EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_get_typeA_0(b2ContactFeature* self) {\n  return self->typeA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_set_typeA_1(b2ContactFeature* self, unsigned char arg0) {\n  self->typeA = arg0;\n}\n\nunsigned char EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_get_typeB_0(b2ContactFeature* self) {\n  return self->typeB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature_set_typeB_1(b2ContactFeature* self, unsigned char arg0) {\n  self->typeB = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactFeature___destroy___0(b2ContactFeature* self) {\n  delete self;\n}\n\n// b2Vec2\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_b2Vec2_0() {\n  return new b2Vec2();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_b2Vec2_2(float arg0, float arg1) {\n  return new b2Vec2(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_SetZero_0(b2Vec2* self) {\n  self->SetZero();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_Set_2(b2Vec2* self, float arg0, float arg1) {\n  self->Set(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_op_add_1(b2Vec2* self, b2Vec2* arg0) {\n  (*self += *arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_op_sub_1(b2Vec2* self, b2Vec2* arg0) {\n  (*self -= *arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_op_mul_1(b2Vec2* self, float arg0) {\n  (*self *= arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_Length_0(b2Vec2* self) {\n  return self->Length();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_LengthSquared_0(b2Vec2* self) {\n  return self->LengthSquared();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_Normalize_0(b2Vec2* self) {\n  return self->Normalize();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_IsValid_0(b2Vec2* self) {\n  return self->IsValid();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_Skew_0(b2Vec2* self) {\n  static b2Vec2 temp;\n  return (temp = self->Skew(), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_get_x_0(b2Vec2* self) {\n  return self->x;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_set_x_1(b2Vec2* self, float arg0) {\n  self->x = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_get_y_0(b2Vec2* self) {\n  return self->y;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2_set_y_1(b2Vec2* self, float arg0) {\n  self->y = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec2___destroy___0(b2Vec2* self) {\n  delete self;\n}\n\n// b2Vec3\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_b2Vec3_0() {\n  return new b2Vec3();\n}\n\nb2Vec3* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_b2Vec3_3(float arg0, float arg1, float arg2) {\n  return new b2Vec3(arg0, arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_SetZero_0(b2Vec3* self) {\n  self->SetZero();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_Set_3(b2Vec3* self, float arg0, float arg1, float arg2) {\n  self->Set(arg0, arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_op_add_1(b2Vec3* self, b2Vec3* arg0) {\n  (*self += *arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_op_sub_1(b2Vec3* self, b2Vec3* arg0) {\n  (*self -= *arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_op_mul_1(b2Vec3* self, float arg0) {\n  (*self *= arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_get_x_0(b2Vec3* self) {\n  return self->x;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_set_x_1(b2Vec3* self, float arg0) {\n  self->x = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_get_y_0(b2Vec3* self) {\n  return self->y;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_set_y_1(b2Vec3* self, float arg0) {\n  self->y = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_get_z_0(b2Vec3* self) {\n  return self->z;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3_set_z_1(b2Vec3* self, float arg0) {\n  self->z = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Vec3___destroy___0(b2Vec3* self) {\n  delete self;\n}\n\n// b2AABB\n\nb2AABB* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_b2AABB_0() {\n  return new b2AABB();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_IsValid_0(b2AABB* self) {\n  return self->IsValid();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_GetCenter_0(b2AABB* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetCenter(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_GetExtents_0(b2AABB* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetExtents(), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_GetPerimeter_0(b2AABB* self) {\n  return self->GetPerimeter();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_Combine_1(b2AABB* self, b2AABB* arg0) {\n  self->Combine(*arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_Combine_2(b2AABB* self, b2AABB* arg0, b2AABB* arg1) {\n  self->Combine(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_Contains_1(b2AABB* self, b2AABB* arg0) {\n  return self->Contains(*arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_RayCast_2(b2AABB* self, b2RayCastOutput* arg0, b2RayCastInput* arg1) {\n  return self->RayCast(arg0, *arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_get_lowerBound_0(b2AABB* self) {\n  return &self->lowerBound;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_set_lowerBound_1(b2AABB* self, b2Vec2* arg0) {\n  self->lowerBound = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_get_upperBound_0(b2AABB* self) {\n  return &self->upperBound;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB_set_upperBound_1(b2AABB* self, b2Vec2* arg0) {\n  self->upperBound = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2AABB___destroy___0(b2AABB* self) {\n  delete self;\n}\n\n// b2FixtureDef\n\nb2FixtureDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_b2FixtureDef_0() {\n  return new b2FixtureDef();\n}\n\nconst b2Shape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_shape_0(b2FixtureDef* self) {\n  return self->shape;\n}\n\nconst void EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_shape_1(b2FixtureDef* self, b2Shape* arg0) {\n  self->shape = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_userData_0(b2FixtureDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_userData_1(b2FixtureDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_friction_0(b2FixtureDef* self) {\n  return self->friction;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_friction_1(b2FixtureDef* self, float arg0) {\n  self->friction = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_restitution_0(b2FixtureDef* self) {\n  return self->restitution;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_restitution_1(b2FixtureDef* self, float arg0) {\n  self->restitution = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_density_0(b2FixtureDef* self) {\n  return self->density;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_density_1(b2FixtureDef* self, float arg0) {\n  self->density = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_isSensor_0(b2FixtureDef* self) {\n  return self->isSensor;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_isSensor_1(b2FixtureDef* self, bool arg0) {\n  self->isSensor = arg0;\n}\n\nb2Filter* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_get_filter_0(b2FixtureDef* self) {\n  return &self->filter;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef_set_filter_1(b2FixtureDef* self, b2Filter* arg0) {\n  self->filter = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FixtureDef___destroy___0(b2FixtureDef* self) {\n  delete self;\n}\n\n// b2FrictionJointDef\n\nb2FrictionJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_b2FrictionJointDef_0() {\n  return new b2FrictionJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_Initialize_3(b2FrictionJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2) {\n  self->Initialize(arg0, arg1, *arg2);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_localAnchorA_0(b2FrictionJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_localAnchorA_1(b2FrictionJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_localAnchorB_0(b2FrictionJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_localAnchorB_1(b2FrictionJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_maxForce_0(b2FrictionJointDef* self) {\n  return self->maxForce;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_maxForce_1(b2FrictionJointDef* self, float arg0) {\n  self->maxForce = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_maxTorque_0(b2FrictionJointDef* self) {\n  return self->maxTorque;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_maxTorque_1(b2FrictionJointDef* self, float arg0) {\n  self->maxTorque = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_type_0(b2FrictionJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_type_1(b2FrictionJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_userData_0(b2FrictionJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_userData_1(b2FrictionJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_bodyA_0(b2FrictionJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_bodyA_1(b2FrictionJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_bodyB_0(b2FrictionJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_bodyB_1(b2FrictionJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_get_collideConnected_0(b2FrictionJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef_set_collideConnected_1(b2FrictionJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJointDef___destroy___0(b2FrictionJointDef* self) {\n  delete self;\n}\n\n// b2Manifold\n\nb2Manifold* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_b2Manifold_0() {\n  return new b2Manifold();\n}\n\nb2ManifoldPoint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_get_points_1(b2Manifold* self, int arg0) {\n  return &self->points[arg0];\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_set_points_2(b2Manifold* self, int arg0, b2ManifoldPoint* arg1) {\n  self->points[arg0] = *arg1;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_get_localNormal_0(b2Manifold* self) {\n  return &self->localNormal;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_set_localNormal_1(b2Manifold* self, b2Vec2* arg0) {\n  self->localNormal = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_get_localPoint_0(b2Manifold* self) {\n  return &self->localPoint;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_set_localPoint_1(b2Manifold* self, b2Vec2* arg0) {\n  self->localPoint = *arg0;\n}\n\nb2ManifoldType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_get_type_0(b2Manifold* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_set_type_1(b2Manifold* self, b2ManifoldType arg0) {\n  self->type = arg0;\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_get_pointCount_0(b2Manifold* self) {\n  return self->pointCount;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold_set_pointCount_1(b2Manifold* self, int arg0) {\n  self->pointCount = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Manifold___destroy___0(b2Manifold* self) {\n  delete self;\n}\n\n// b2WorldManifold\n\nb2WorldManifold* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WorldManifold_b2WorldManifold_0() {\n  return new b2WorldManifold();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WorldManifold_Initialize_5(b2WorldManifold* self, b2Manifold* arg0, b2Transform* arg1, float arg2, b2Transform* arg3, float arg4) {\n  self->Initialize(arg0, *arg1, arg2, *arg3, arg4);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WorldManifold_get_normal_0(b2WorldManifold* self) {\n  return &self->normal;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WorldManifold_set_normal_1(b2WorldManifold* self, b2Vec2* arg0) {\n  self->normal = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WorldManifold_get_points_1(b2WorldManifold* self, int arg0) {\n  return &self->points[arg0];\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WorldManifold_set_points_2(b2WorldManifold* self, int arg0, b2Vec2* arg1) {\n  self->points[arg0] = *arg1;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WorldManifold___destroy___0(b2WorldManifold* self) {\n  delete self;\n}\n\n// b2PrismaticJointDef\n\nb2PrismaticJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_b2PrismaticJointDef_0() {\n  return new b2PrismaticJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_Initialize_4(b2PrismaticJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2, b2Vec2* arg3) {\n  self->Initialize(arg0, arg1, *arg2, *arg3);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_localAnchorA_0(b2PrismaticJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_localAnchorA_1(b2PrismaticJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_localAnchorB_0(b2PrismaticJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_localAnchorB_1(b2PrismaticJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_localAxisA_0(b2PrismaticJointDef* self) {\n  return &self->localAxisA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_localAxisA_1(b2PrismaticJointDef* self, b2Vec2* arg0) {\n  self->localAxisA = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_referenceAngle_0(b2PrismaticJointDef* self) {\n  return self->referenceAngle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_referenceAngle_1(b2PrismaticJointDef* self, float arg0) {\n  self->referenceAngle = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_enableLimit_0(b2PrismaticJointDef* self) {\n  return self->enableLimit;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_enableLimit_1(b2PrismaticJointDef* self, bool arg0) {\n  self->enableLimit = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_lowerTranslation_0(b2PrismaticJointDef* self) {\n  return self->lowerTranslation;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_lowerTranslation_1(b2PrismaticJointDef* self, float arg0) {\n  self->lowerTranslation = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_upperTranslation_0(b2PrismaticJointDef* self) {\n  return self->upperTranslation;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_upperTranslation_1(b2PrismaticJointDef* self, float arg0) {\n  self->upperTranslation = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_enableMotor_0(b2PrismaticJointDef* self) {\n  return self->enableMotor;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_enableMotor_1(b2PrismaticJointDef* self, bool arg0) {\n  self->enableMotor = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_maxMotorForce_0(b2PrismaticJointDef* self) {\n  return self->maxMotorForce;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_maxMotorForce_1(b2PrismaticJointDef* self, float arg0) {\n  self->maxMotorForce = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_motorSpeed_0(b2PrismaticJointDef* self) {\n  return self->motorSpeed;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_motorSpeed_1(b2PrismaticJointDef* self, float arg0) {\n  self->motorSpeed = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_type_0(b2PrismaticJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_type_1(b2PrismaticJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_userData_0(b2PrismaticJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_userData_1(b2PrismaticJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_bodyA_0(b2PrismaticJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_bodyA_1(b2PrismaticJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_bodyB_0(b2PrismaticJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_bodyB_1(b2PrismaticJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_get_collideConnected_0(b2PrismaticJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef_set_collideConnected_1(b2PrismaticJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJointDef___destroy___0(b2PrismaticJointDef* self) {\n  delete self;\n}\n\n// b2World\n\nb2World* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_b2World_1(b2Vec2* arg0) {\n  return new b2World(*arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetDestructionListener_1(b2World* self, b2DestructionListener* arg0) {\n  self->SetDestructionListener(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetContactFilter_1(b2World* self, JSContactFilter* arg0) {\n  self->SetContactFilter(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetContactListener_1(b2World* self, JSContactListener* arg0) {\n  self->SetContactListener(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetDebugDraw_1(b2World* self, b2Draw* arg0) {\n  self->SetDebugDraw(arg0);\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_CreateBody_1(b2World* self, b2BodyDef* arg0) {\n  return self->CreateBody(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_DestroyBody_1(b2World* self, b2Body* arg0) {\n  self->DestroyBody(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_CreateJoint_1(b2World* self, b2JointDef* arg0) {\n  return self->CreateJoint(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_DestroyJoint_1(b2World* self, b2Joint* arg0) {\n  self->DestroyJoint(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_Step_3(b2World* self, float arg0, int arg1, int arg2) {\n  self->Step(arg0, arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_ClearForces_0(b2World* self) {\n  self->ClearForces();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_DrawDebugData_0(b2World* self) {\n  self->DrawDebugData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_QueryAABB_2(b2World* self, b2QueryCallback* arg0, b2AABB* arg1) {\n  self->QueryAABB(arg0, *arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_RayCast_3(b2World* self, b2RayCastCallback* arg0, b2Vec2* arg1, b2Vec2* arg2) {\n  self->RayCast(arg0, *arg1, *arg2);\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetBodyList_0(b2World* self) {\n  return self->GetBodyList();\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetJointList_0(b2World* self) {\n  return self->GetJointList();\n}\n\nb2Contact* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetContactList_0(b2World* self) {\n  return self->GetContactList();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetAllowSleeping_1(b2World* self, bool arg0) {\n  self->SetAllowSleeping(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetAllowSleeping_0(b2World* self) {\n  return self->GetAllowSleeping();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetWarmStarting_1(b2World* self, bool arg0) {\n  self->SetWarmStarting(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetWarmStarting_0(b2World* self) {\n  return self->GetWarmStarting();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetContinuousPhysics_1(b2World* self, bool arg0) {\n  self->SetContinuousPhysics(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetContinuousPhysics_0(b2World* self) {\n  return self->GetContinuousPhysics();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetSubStepping_1(b2World* self, bool arg0) {\n  self->SetSubStepping(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetSubStepping_0(b2World* self) {\n  return self->GetSubStepping();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetProxyCount_0(b2World* self) {\n  return self->GetProxyCount();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetBodyCount_0(b2World* self) {\n  return self->GetBodyCount();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetJointCount_0(b2World* self) {\n  return self->GetJointCount();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetContactCount_0(b2World* self) {\n  return self->GetContactCount();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetTreeHeight_0(b2World* self) {\n  return self->GetTreeHeight();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetTreeBalance_0(b2World* self) {\n  return self->GetTreeBalance();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetTreeQuality_0(b2World* self) {\n  return self->GetTreeQuality();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetGravity_1(b2World* self, b2Vec2* arg0) {\n  self->SetGravity(*arg0);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetGravity_0(b2World* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetGravity(), &temp);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_IsLocked_0(b2World* self) {\n  return self->IsLocked();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_SetAutoClearForces_1(b2World* self, bool arg0) {\n  self->SetAutoClearForces(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetAutoClearForces_0(b2World* self) {\n  return self->GetAutoClearForces();\n}\n\nconst b2Profile* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_GetProfile_0(b2World* self) {\n  return &self->GetProfile();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World_Dump_0(b2World* self) {\n  self->Dump();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2World___destroy___0(b2World* self) {\n  delete self;\n}\n\n// b2PrismaticJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetLocalAnchorA_0(b2PrismaticJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetLocalAnchorB_0(b2PrismaticJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetLocalAxisA_0(b2PrismaticJoint* self) {\n  return &self->GetLocalAxisA();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetReferenceAngle_0(b2PrismaticJoint* self) {\n  return self->GetReferenceAngle();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetJointTranslation_0(b2PrismaticJoint* self) {\n  return self->GetJointTranslation();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetJointSpeed_0(b2PrismaticJoint* self) {\n  return self->GetJointSpeed();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_IsLimitEnabled_0(b2PrismaticJoint* self) {\n  return self->IsLimitEnabled();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_EnableLimit_1(b2PrismaticJoint* self, bool arg0) {\n  self->EnableLimit(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetLowerLimit_0(b2PrismaticJoint* self) {\n  return self->GetLowerLimit();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetUpperLimit_0(b2PrismaticJoint* self) {\n  return self->GetUpperLimit();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_SetLimits_2(b2PrismaticJoint* self, float arg0, float arg1) {\n  self->SetLimits(arg0, arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_IsMotorEnabled_0(b2PrismaticJoint* self) {\n  return self->IsMotorEnabled();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_EnableMotor_1(b2PrismaticJoint* self, bool arg0) {\n  self->EnableMotor(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_SetMotorSpeed_1(b2PrismaticJoint* self, float arg0) {\n  self->SetMotorSpeed(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetMotorSpeed_0(b2PrismaticJoint* self) {\n  return self->GetMotorSpeed();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_SetMaxMotorForce_1(b2PrismaticJoint* self, float arg0) {\n  self->SetMaxMotorForce(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetMaxMotorForce_0(b2PrismaticJoint* self) {\n  return self->GetMaxMotorForce();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetMotorForce_1(b2PrismaticJoint* self, float arg0) {\n  return self->GetMotorForce(arg0);\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetType_0(b2PrismaticJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetBodyA_0(b2PrismaticJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetBodyB_0(b2PrismaticJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetAnchorA_0(b2PrismaticJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetAnchorB_0(b2PrismaticJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetReactionForce_1(b2PrismaticJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetReactionTorque_1(b2PrismaticJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetNext_0(b2PrismaticJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetUserData_0(b2PrismaticJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_SetUserData_1(b2PrismaticJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_IsActive_0(b2PrismaticJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint_GetCollideConnected_0(b2PrismaticJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PrismaticJoint___destroy___0(b2PrismaticJoint* self) {\n  delete self;\n}\n\n// b2RayCastOutput\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastOutput_get_normal_0(b2RayCastOutput* self) {\n  return &self->normal;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastOutput_set_normal_1(b2RayCastOutput* self, b2Vec2* arg0) {\n  self->normal = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastOutput_get_fraction_0(b2RayCastOutput* self) {\n  return self->fraction;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastOutput_set_fraction_1(b2RayCastOutput* self, float arg0) {\n  self->fraction = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastOutput___destroy___0(b2RayCastOutput* self) {\n  delete self;\n}\n\n// b2ContactID\n\nb2ContactFeature* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactID_get_cf_0(b2ContactID* self) {\n  return &self->cf;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactID_set_cf_1(b2ContactID* self, b2ContactFeature* arg0) {\n  self->cf = *arg0;\n}\n\nunsigned int EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactID_get_key_0(b2ContactID* self) {\n  return self->key;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactID_set_key_1(b2ContactID* self, unsigned int arg0) {\n  self->key = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactID___destroy___0(b2ContactID* self) {\n  delete self;\n}\n\n// JSContactListener\n\nJSContactListener* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener_JSContactListener_0() {\n  return new JSContactListener();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener_BeginContact_1(JSContactListener* self, b2Contact* arg0) {\n  self->BeginContact(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener_EndContact_1(JSContactListener* self, b2Contact* arg0) {\n  self->EndContact(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener_PreSolve_2(JSContactListener* self, b2Contact* arg0, b2Manifold* arg1) {\n  self->PreSolve(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener_PostSolve_2(JSContactListener* self, b2Contact* arg0, b2ContactImpulse* arg1) {\n  self->PostSolve(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactListener___destroy___0(JSContactListener* self) {\n  delete self;\n}\n\n// b2Mat22\n\nb2Mat22* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_b2Mat22_0() {\n  return new b2Mat22();\n}\n\nb2Mat22* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_b2Mat22_2(b2Vec2* arg0, b2Vec2* arg1) {\n  return new b2Mat22(*arg0, *arg1);\n}\n\nb2Mat22* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_b2Mat22_4(float arg0, float arg1, float arg2, float arg3) {\n  return new b2Mat22(arg0, arg1, arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_Set_2(b2Mat22* self, b2Vec2* arg0, b2Vec2* arg1) {\n  self->Set(*arg0, *arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_SetIdentity_0(b2Mat22* self) {\n  self->SetIdentity();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_SetZero_0(b2Mat22* self) {\n  self->SetZero();\n}\n\nb2Mat22* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_GetInverse_0(b2Mat22* self) {\n  static b2Mat22 temp;\n  return (temp = self->GetInverse(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_Solve_1(b2Mat22* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->Solve(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_get_ex_0(b2Mat22* self) {\n  return &self->ex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_set_ex_1(b2Mat22* self, b2Vec2* arg0) {\n  self->ex = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_get_ey_0(b2Mat22* self) {\n  return &self->ey;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22_set_ey_1(b2Mat22* self, b2Vec2* arg0) {\n  self->ey = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Mat22___destroy___0(b2Mat22* self) {\n  delete self;\n}\n\n// b2WheelJointDef\n\nb2WheelJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_b2WheelJointDef_0() {\n  return new b2WheelJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_Initialize_4(b2WheelJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2, b2Vec2* arg3) {\n  self->Initialize(arg0, arg1, *arg2, *arg3);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_localAnchorA_0(b2WheelJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_localAnchorA_1(b2WheelJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_localAnchorB_0(b2WheelJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_localAnchorB_1(b2WheelJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_localAxisA_0(b2WheelJointDef* self) {\n  return &self->localAxisA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_localAxisA_1(b2WheelJointDef* self, b2Vec2* arg0) {\n  self->localAxisA = *arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_enableMotor_0(b2WheelJointDef* self) {\n  return self->enableMotor;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_enableMotor_1(b2WheelJointDef* self, bool arg0) {\n  self->enableMotor = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_maxMotorTorque_0(b2WheelJointDef* self) {\n  return self->maxMotorTorque;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_maxMotorTorque_1(b2WheelJointDef* self, float arg0) {\n  self->maxMotorTorque = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_motorSpeed_0(b2WheelJointDef* self) {\n  return self->motorSpeed;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_motorSpeed_1(b2WheelJointDef* self, float arg0) {\n  self->motorSpeed = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_frequencyHz_0(b2WheelJointDef* self) {\n  return self->frequencyHz;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_frequencyHz_1(b2WheelJointDef* self, float arg0) {\n  self->frequencyHz = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_dampingRatio_0(b2WheelJointDef* self) {\n  return self->dampingRatio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_dampingRatio_1(b2WheelJointDef* self, float arg0) {\n  self->dampingRatio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_type_0(b2WheelJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_type_1(b2WheelJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_userData_0(b2WheelJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_userData_1(b2WheelJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_bodyA_0(b2WheelJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_bodyA_1(b2WheelJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_bodyB_0(b2WheelJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_bodyB_1(b2WheelJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_get_collideConnected_0(b2WheelJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef_set_collideConnected_1(b2WheelJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJointDef___destroy___0(b2WheelJointDef* self) {\n  delete self;\n}\n\n// b2CircleShape\n\nb2CircleShape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_b2CircleShape_0() {\n  return new b2CircleShape();\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_GetType_0(b2CircleShape* self) {\n  return self->GetType();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_GetChildCount_0(b2CircleShape* self) {\n  return self->GetChildCount();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_TestPoint_2(b2CircleShape* self, b2Transform* arg0, b2Vec2* arg1) {\n  return self->TestPoint(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_RayCast_4(b2CircleShape* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, b2Transform* arg2, int arg3) {\n  return self->RayCast(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_ComputeAABB_3(b2CircleShape* self, b2AABB* arg0, b2Transform* arg1, int arg2) {\n  self->ComputeAABB(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_ComputeMass_2(b2CircleShape* self, b2MassData* arg0, float arg1) {\n  self->ComputeMass(arg0, arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_get_m_p_0(b2CircleShape* self) {\n  return &self->m_p;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_set_m_p_1(b2CircleShape* self, b2Vec2* arg0) {\n  self->m_p = *arg0;\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_get_m_type_0(b2CircleShape* self) {\n  return self->m_type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_set_m_type_1(b2CircleShape* self, b2ShapeType arg0) {\n  self->m_type = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_get_m_radius_0(b2CircleShape* self) {\n  return self->m_radius;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape_set_m_radius_1(b2CircleShape* self, float arg0) {\n  self->m_radius = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2CircleShape___destroy___0(b2CircleShape* self) {\n  delete self;\n}\n\n// b2WeldJointDef\n\nb2WeldJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_b2WeldJointDef_0() {\n  return new b2WeldJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_Initialize_3(b2WeldJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2) {\n  self->Initialize(arg0, arg1, *arg2);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_localAnchorA_0(b2WeldJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_localAnchorA_1(b2WeldJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_localAnchorB_0(b2WeldJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_localAnchorB_1(b2WeldJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_referenceAngle_0(b2WeldJointDef* self) {\n  return self->referenceAngle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_referenceAngle_1(b2WeldJointDef* self, float arg0) {\n  self->referenceAngle = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_frequencyHz_0(b2WeldJointDef* self) {\n  return self->frequencyHz;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_frequencyHz_1(b2WeldJointDef* self, float arg0) {\n  self->frequencyHz = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_dampingRatio_0(b2WeldJointDef* self) {\n  return self->dampingRatio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_dampingRatio_1(b2WeldJointDef* self, float arg0) {\n  self->dampingRatio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_type_0(b2WeldJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_type_1(b2WeldJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_userData_0(b2WeldJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_userData_1(b2WeldJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_bodyA_0(b2WeldJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_bodyA_1(b2WeldJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_bodyB_0(b2WeldJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_bodyB_1(b2WeldJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_get_collideConnected_0(b2WeldJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef_set_collideConnected_1(b2WeldJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJointDef___destroy___0(b2WeldJointDef* self) {\n  delete self;\n}\n\n// b2MassData\n\nb2MassData* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_b2MassData_0() {\n  return new b2MassData();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_get_mass_0(b2MassData* self) {\n  return self->mass;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_set_mass_1(b2MassData* self, float arg0) {\n  self->mass = arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_get_center_0(b2MassData* self) {\n  return &self->center;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_set_center_1(b2MassData* self, b2Vec2* arg0) {\n  self->center = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_get_I_0(b2MassData* self) {\n  return self->I;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData_set_I_1(b2MassData* self, float arg0) {\n  self->I = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MassData___destroy___0(b2MassData* self) {\n  delete self;\n}\n\n// b2GearJoint\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetJoint1_0(b2GearJoint* self) {\n  return self->GetJoint1();\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetJoint2_0(b2GearJoint* self) {\n  return self->GetJoint2();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_SetRatio_1(b2GearJoint* self, float arg0) {\n  self->SetRatio(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetRatio_0(b2GearJoint* self) {\n  return self->GetRatio();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetType_0(b2GearJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetBodyA_0(b2GearJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetBodyB_0(b2GearJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetAnchorA_0(b2GearJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetAnchorB_0(b2GearJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetReactionForce_1(b2GearJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetReactionTorque_1(b2GearJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetNext_0(b2GearJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetUserData_0(b2GearJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_SetUserData_1(b2GearJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_IsActive_0(b2GearJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint_GetCollideConnected_0(b2GearJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJoint___destroy___0(b2GearJoint* self) {\n  delete self;\n}\n\n// b2WeldJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetLocalAnchorA_0(b2WeldJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetLocalAnchorB_0(b2WeldJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_SetFrequency_1(b2WeldJoint* self, float arg0) {\n  self->SetFrequency(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetFrequency_0(b2WeldJoint* self) {\n  return self->GetFrequency();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_SetDampingRatio_1(b2WeldJoint* self, float arg0) {\n  self->SetDampingRatio(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetDampingRatio_0(b2WeldJoint* self) {\n  return self->GetDampingRatio();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_Dump_0(b2WeldJoint* self) {\n  self->Dump();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetType_0(b2WeldJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetBodyA_0(b2WeldJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetBodyB_0(b2WeldJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetAnchorA_0(b2WeldJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetAnchorB_0(b2WeldJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetReactionForce_1(b2WeldJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetReactionTorque_1(b2WeldJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetNext_0(b2WeldJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetUserData_0(b2WeldJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_SetUserData_1(b2WeldJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_IsActive_0(b2WeldJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint_GetCollideConnected_0(b2WeldJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WeldJoint___destroy___0(b2WeldJoint* self) {\n  delete self;\n}\n\n// b2JointEdge\n\nb2JointEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_b2JointEdge_0() {\n  return new b2JointEdge();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_get_other_0(b2JointEdge* self) {\n  return self->other;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_set_other_1(b2JointEdge* self, b2Body* arg0) {\n  self->other = arg0;\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_get_joint_0(b2JointEdge* self) {\n  return self->joint;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_set_joint_1(b2JointEdge* self, b2Joint* arg0) {\n  self->joint = arg0;\n}\n\nb2JointEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_get_prev_0(b2JointEdge* self) {\n  return self->prev;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_set_prev_1(b2JointEdge* self, b2JointEdge* arg0) {\n  self->prev = arg0;\n}\n\nb2JointEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_get_next_0(b2JointEdge* self) {\n  return self->next;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge_set_next_1(b2JointEdge* self, b2JointEdge* arg0) {\n  self->next = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2JointEdge___destroy___0(b2JointEdge* self) {\n  delete self;\n}\n\n// b2PulleyJointDef\n\nb2PulleyJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_b2PulleyJointDef_0() {\n  return new b2PulleyJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_Initialize_7(b2PulleyJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2, b2Vec2* arg3, b2Vec2* arg4, b2Vec2* arg5, float arg6) {\n  self->Initialize(arg0, arg1, *arg2, *arg3, *arg4, *arg5, arg6);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_groundAnchorA_0(b2PulleyJointDef* self) {\n  return &self->groundAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_groundAnchorA_1(b2PulleyJointDef* self, b2Vec2* arg0) {\n  self->groundAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_groundAnchorB_0(b2PulleyJointDef* self) {\n  return &self->groundAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_groundAnchorB_1(b2PulleyJointDef* self, b2Vec2* arg0) {\n  self->groundAnchorB = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_localAnchorA_0(b2PulleyJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_localAnchorA_1(b2PulleyJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_localAnchorB_0(b2PulleyJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_localAnchorB_1(b2PulleyJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_lengthA_0(b2PulleyJointDef* self) {\n  return self->lengthA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_lengthA_1(b2PulleyJointDef* self, float arg0) {\n  self->lengthA = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_lengthB_0(b2PulleyJointDef* self) {\n  return self->lengthB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_lengthB_1(b2PulleyJointDef* self, float arg0) {\n  self->lengthB = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_ratio_0(b2PulleyJointDef* self) {\n  return self->ratio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_ratio_1(b2PulleyJointDef* self, float arg0) {\n  self->ratio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_type_0(b2PulleyJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_type_1(b2PulleyJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_userData_0(b2PulleyJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_userData_1(b2PulleyJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_bodyA_0(b2PulleyJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_bodyA_1(b2PulleyJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_bodyB_0(b2PulleyJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_bodyB_1(b2PulleyJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_get_collideConnected_0(b2PulleyJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef_set_collideConnected_1(b2PulleyJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJointDef___destroy___0(b2PulleyJointDef* self) {\n  delete self;\n}\n\n// b2ManifoldPoint\n\nb2ManifoldPoint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_b2ManifoldPoint_0() {\n  return new b2ManifoldPoint();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_get_localPoint_0(b2ManifoldPoint* self) {\n  return &self->localPoint;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_set_localPoint_1(b2ManifoldPoint* self, b2Vec2* arg0) {\n  self->localPoint = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_get_normalImpulse_0(b2ManifoldPoint* self) {\n  return self->normalImpulse;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_set_normalImpulse_1(b2ManifoldPoint* self, float arg0) {\n  self->normalImpulse = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_get_tangentImpulse_0(b2ManifoldPoint* self) {\n  return self->tangentImpulse;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_set_tangentImpulse_1(b2ManifoldPoint* self, float arg0) {\n  self->tangentImpulse = arg0;\n}\n\nb2ContactID* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_get_id_0(b2ManifoldPoint* self) {\n  return &self->id;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint_set_id_1(b2ManifoldPoint* self, b2ContactID* arg0) {\n  self->id = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ManifoldPoint___destroy___0(b2ManifoldPoint* self) {\n  delete self;\n}\n\n// b2Transform\n\nb2Transform* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_b2Transform_0() {\n  return new b2Transform();\n}\n\nb2Transform* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_b2Transform_2(b2Vec2* arg0, b2Rot* arg1) {\n  return new b2Transform(*arg0, *arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_SetIdentity_0(b2Transform* self) {\n  self->SetIdentity();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_Set_2(b2Transform* self, b2Vec2* arg0, float arg1) {\n  self->Set(*arg0, arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_get_p_0(b2Transform* self) {\n  return &self->p;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_set_p_1(b2Transform* self, b2Vec2* arg0) {\n  self->p = *arg0;\n}\n\nb2Rot* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_get_q_0(b2Transform* self) {\n  return &self->q;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform_set_q_1(b2Transform* self, b2Rot* arg0) {\n  self->q = *arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Transform___destroy___0(b2Transform* self) {\n  delete self;\n}\n\n// b2ChainShape\n\nb2ChainShape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_b2ChainShape_0() {\n  return new b2ChainShape();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_Clear_0(b2ChainShape* self) {\n  self->Clear();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_CreateLoop_2(b2ChainShape* self, b2Vec2* arg0, int arg1) {\n  self->CreateLoop(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_CreateChain_2(b2ChainShape* self, b2Vec2* arg0, int arg1) {\n  self->CreateChain(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_SetPrevVertex_1(b2ChainShape* self, b2Vec2* arg0) {\n  self->SetPrevVertex(*arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_SetNextVertex_1(b2ChainShape* self, b2Vec2* arg0) {\n  self->SetNextVertex(*arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_GetChildEdge_2(b2ChainShape* self, b2EdgeShape* arg0, int arg1) {\n  self->GetChildEdge(arg0, arg1);\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_GetType_0(b2ChainShape* self) {\n  return self->GetType();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_GetChildCount_0(b2ChainShape* self) {\n  return self->GetChildCount();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_TestPoint_2(b2ChainShape* self, b2Transform* arg0, b2Vec2* arg1) {\n  return self->TestPoint(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_RayCast_4(b2ChainShape* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, b2Transform* arg2, int arg3) {\n  return self->RayCast(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_ComputeAABB_3(b2ChainShape* self, b2AABB* arg0, b2Transform* arg1, int arg2) {\n  self->ComputeAABB(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_ComputeMass_2(b2ChainShape* self, b2MassData* arg0, float arg1) {\n  self->ComputeMass(arg0, arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_vertices_0(b2ChainShape* self) {\n  return self->m_vertices;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_vertices_1(b2ChainShape* self, b2Vec2* arg0) {\n  self->m_vertices = arg0;\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_count_0(b2ChainShape* self) {\n  return self->m_count;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_count_1(b2ChainShape* self, int arg0) {\n  self->m_count = arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_prevVertex_0(b2ChainShape* self) {\n  return &self->m_prevVertex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_prevVertex_1(b2ChainShape* self, b2Vec2* arg0) {\n  self->m_prevVertex = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_nextVertex_0(b2ChainShape* self) {\n  return &self->m_nextVertex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_nextVertex_1(b2ChainShape* self, b2Vec2* arg0) {\n  self->m_nextVertex = *arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_hasPrevVertex_0(b2ChainShape* self) {\n  return self->m_hasPrevVertex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_hasPrevVertex_1(b2ChainShape* self, bool arg0) {\n  self->m_hasPrevVertex = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_hasNextVertex_0(b2ChainShape* self) {\n  return self->m_hasNextVertex;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_hasNextVertex_1(b2ChainShape* self, bool arg0) {\n  self->m_hasNextVertex = arg0;\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_type_0(b2ChainShape* self) {\n  return self->m_type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_type_1(b2ChainShape* self, b2ShapeType arg0) {\n  self->m_type = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_get_m_radius_0(b2ChainShape* self) {\n  return self->m_radius;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape_set_m_radius_1(b2ChainShape* self, float arg0) {\n  self->m_radius = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ChainShape___destroy___0(b2ChainShape* self) {\n  delete self;\n}\n\n// b2Color\n\nb2Color* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_b2Color_0() {\n  return new b2Color();\n}\n\nb2Color* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_b2Color_3(float arg0, float arg1, float arg2) {\n  return new b2Color(arg0, arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_Set_3(b2Color* self, float arg0, float arg1, float arg2) {\n  self->Set(arg0, arg1, arg2);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_get_r_0(b2Color* self) {\n  return self->r;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_set_r_1(b2Color* self, float arg0) {\n  self->r = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_get_g_0(b2Color* self) {\n  return self->g;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_set_g_1(b2Color* self, float arg0) {\n  self->g = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_get_b_0(b2Color* self) {\n  return self->b;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color_set_b_1(b2Color* self, float arg0) {\n  self->b = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Color___destroy___0(b2Color* self) {\n  delete self;\n}\n\n// b2RopeJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetLocalAnchorA_0(b2RopeJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetLocalAnchorB_0(b2RopeJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_SetMaxLength_1(b2RopeJoint* self, float arg0) {\n  self->SetMaxLength(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetMaxLength_0(b2RopeJoint* self) {\n  return self->GetMaxLength();\n}\n\nb2LimitState EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetLimitState_0(b2RopeJoint* self) {\n  return self->GetLimitState();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetType_0(b2RopeJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetBodyA_0(b2RopeJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetBodyB_0(b2RopeJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetAnchorA_0(b2RopeJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetAnchorB_0(b2RopeJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetReactionForce_1(b2RopeJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetReactionTorque_1(b2RopeJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetNext_0(b2RopeJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetUserData_0(b2RopeJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_SetUserData_1(b2RopeJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_IsActive_0(b2RopeJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint_GetCollideConnected_0(b2RopeJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJoint___destroy___0(b2RopeJoint* self) {\n  delete self;\n}\n\n// b2RayCastInput\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_get_p1_0(b2RayCastInput* self) {\n  return &self->p1;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_set_p1_1(b2RayCastInput* self, b2Vec2* arg0) {\n  self->p1 = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_get_p2_0(b2RayCastInput* self) {\n  return &self->p2;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_set_p2_1(b2RayCastInput* self, b2Vec2* arg0) {\n  self->p2 = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_get_maxFraction_0(b2RayCastInput* self) {\n  return self->maxFraction;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput_set_maxFraction_1(b2RayCastInput* self, float arg0) {\n  self->maxFraction = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RayCastInput___destroy___0(b2RayCastInput* self) {\n  delete self;\n}\n\n// b2PolygonShape\n\nb2PolygonShape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_b2PolygonShape_0() {\n  return new b2PolygonShape();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_Set_2(b2PolygonShape* self, b2Vec2* arg0, int arg1) {\n  self->Set(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_SetAsBox_2(b2PolygonShape* self, float arg0, float arg1) {\n  self->SetAsBox(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_SetAsBox_4(b2PolygonShape* self, float arg0, float arg1, b2Vec2* arg2, float arg3) {\n  self->SetAsBox(arg0, arg1, *arg2, arg3);\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_GetVertexCount_0(b2PolygonShape* self) {\n  return self->GetVertexCount();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_GetVertex_1(b2PolygonShape* self, int arg0) {\n  return &self->GetVertex(arg0);\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_GetType_0(b2PolygonShape* self) {\n  return self->GetType();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_GetChildCount_0(b2PolygonShape* self) {\n  return self->GetChildCount();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_TestPoint_2(b2PolygonShape* self, b2Transform* arg0, b2Vec2* arg1) {\n  return self->TestPoint(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_RayCast_4(b2PolygonShape* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, b2Transform* arg2, int arg3) {\n  return self->RayCast(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_ComputeAABB_3(b2PolygonShape* self, b2AABB* arg0, b2Transform* arg1, int arg2) {\n  self->ComputeAABB(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_ComputeMass_2(b2PolygonShape* self, b2MassData* arg0, float arg1) {\n  self->ComputeMass(arg0, arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_get_m_centroid_0(b2PolygonShape* self) {\n  return &self->m_centroid;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_set_m_centroid_1(b2PolygonShape* self, b2Vec2* arg0) {\n  self->m_centroid = *arg0;\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_get_m_count_0(b2PolygonShape* self) {\n  return self->m_count;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_set_m_count_1(b2PolygonShape* self, int arg0) {\n  self->m_count = arg0;\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_get_m_type_0(b2PolygonShape* self) {\n  return self->m_type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_set_m_type_1(b2PolygonShape* self, b2ShapeType arg0) {\n  self->m_type = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_get_m_radius_0(b2PolygonShape* self) {\n  return self->m_radius;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape_set_m_radius_1(b2PolygonShape* self, float arg0) {\n  self->m_radius = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PolygonShape___destroy___0(b2PolygonShape* self) {\n  delete self;\n}\n\n// b2EdgeShape\n\nb2EdgeShape* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_b2EdgeShape_0() {\n  return new b2EdgeShape();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_Set_2(b2EdgeShape* self, b2Vec2* arg0, b2Vec2* arg1) {\n  self->Set(*arg0, *arg1);\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_GetType_0(b2EdgeShape* self) {\n  return self->GetType();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_GetChildCount_0(b2EdgeShape* self) {\n  return self->GetChildCount();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_TestPoint_2(b2EdgeShape* self, b2Transform* arg0, b2Vec2* arg1) {\n  return self->TestPoint(*arg0, *arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_RayCast_4(b2EdgeShape* self, b2RayCastOutput* arg0, b2RayCastInput* arg1, b2Transform* arg2, int arg3) {\n  return self->RayCast(arg0, *arg1, *arg2, arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_ComputeAABB_3(b2EdgeShape* self, b2AABB* arg0, b2Transform* arg1, int arg2) {\n  self->ComputeAABB(arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_ComputeMass_2(b2EdgeShape* self, b2MassData* arg0, float arg1) {\n  self->ComputeMass(arg0, arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_vertex1_0(b2EdgeShape* self) {\n  return &self->m_vertex1;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_vertex1_1(b2EdgeShape* self, b2Vec2* arg0) {\n  self->m_vertex1 = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_vertex2_0(b2EdgeShape* self) {\n  return &self->m_vertex2;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_vertex2_1(b2EdgeShape* self, b2Vec2* arg0) {\n  self->m_vertex2 = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_vertex0_0(b2EdgeShape* self) {\n  return &self->m_vertex0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_vertex0_1(b2EdgeShape* self, b2Vec2* arg0) {\n  self->m_vertex0 = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_vertex3_0(b2EdgeShape* self) {\n  return &self->m_vertex3;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_vertex3_1(b2EdgeShape* self, b2Vec2* arg0) {\n  self->m_vertex3 = *arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_hasVertex0_0(b2EdgeShape* self) {\n  return self->m_hasVertex0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_hasVertex0_1(b2EdgeShape* self, bool arg0) {\n  self->m_hasVertex0 = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_hasVertex3_0(b2EdgeShape* self) {\n  return self->m_hasVertex3;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_hasVertex3_1(b2EdgeShape* self, bool arg0) {\n  self->m_hasVertex3 = arg0;\n}\n\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_type_0(b2EdgeShape* self) {\n  return self->m_type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_type_1(b2EdgeShape* self, b2ShapeType arg0) {\n  self->m_type = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_get_m_radius_0(b2EdgeShape* self) {\n  return self->m_radius;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape_set_m_radius_1(b2EdgeShape* self, float arg0) {\n  self->m_radius = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2EdgeShape___destroy___0(b2EdgeShape* self) {\n  delete self;\n}\n\n// JSContactFilter\n\nJSContactFilter* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactFilter_JSContactFilter_0() {\n  return new JSContactFilter();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactFilter_ShouldCollide_2(JSContactFilter* self, b2Fixture* arg0, b2Fixture* arg1) {\n  return self->ShouldCollide(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSContactFilter___destroy___0(JSContactFilter* self) {\n  delete self;\n}\n\n// b2RevoluteJointDef\n\nb2RevoluteJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_b2RevoluteJointDef_0() {\n  return new b2RevoluteJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_Initialize_3(b2RevoluteJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2) {\n  self->Initialize(arg0, arg1, *arg2);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_localAnchorA_0(b2RevoluteJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_localAnchorA_1(b2RevoluteJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_localAnchorB_0(b2RevoluteJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_localAnchorB_1(b2RevoluteJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_referenceAngle_0(b2RevoluteJointDef* self) {\n  return self->referenceAngle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_referenceAngle_1(b2RevoluteJointDef* self, float arg0) {\n  self->referenceAngle = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_enableLimit_0(b2RevoluteJointDef* self) {\n  return self->enableLimit;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_enableLimit_1(b2RevoluteJointDef* self, bool arg0) {\n  self->enableLimit = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_lowerAngle_0(b2RevoluteJointDef* self) {\n  return self->lowerAngle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_lowerAngle_1(b2RevoluteJointDef* self, float arg0) {\n  self->lowerAngle = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_upperAngle_0(b2RevoluteJointDef* self) {\n  return self->upperAngle;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_upperAngle_1(b2RevoluteJointDef* self, float arg0) {\n  self->upperAngle = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_enableMotor_0(b2RevoluteJointDef* self) {\n  return self->enableMotor;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_enableMotor_1(b2RevoluteJointDef* self, bool arg0) {\n  self->enableMotor = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_motorSpeed_0(b2RevoluteJointDef* self) {\n  return self->motorSpeed;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_motorSpeed_1(b2RevoluteJointDef* self, float arg0) {\n  self->motorSpeed = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_maxMotorTorque_0(b2RevoluteJointDef* self) {\n  return self->maxMotorTorque;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_maxMotorTorque_1(b2RevoluteJointDef* self, float arg0) {\n  self->maxMotorTorque = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_type_0(b2RevoluteJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_type_1(b2RevoluteJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_userData_0(b2RevoluteJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_userData_1(b2RevoluteJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_bodyA_0(b2RevoluteJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_bodyA_1(b2RevoluteJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_bodyB_0(b2RevoluteJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_bodyB_1(b2RevoluteJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_get_collideConnected_0(b2RevoluteJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef_set_collideConnected_1(b2RevoluteJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJointDef___destroy___0(b2RevoluteJointDef* self) {\n  delete self;\n}\n\n// JSDraw\n\nJSDraw* EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_JSDraw_0() {\n  return new JSDraw();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawPolygon_3(JSDraw* self, b2Vec2* arg0, int arg1, b2Color* arg2) {\n  self->DrawPolygon(arg0, arg1, *arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawSolidPolygon_3(JSDraw* self, b2Vec2* arg0, int arg1, b2Color* arg2) {\n  self->DrawSolidPolygon(arg0, arg1, *arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawCircle_3(JSDraw* self, b2Vec2* arg0, float arg1, b2Color* arg2) {\n  self->DrawCircle(*arg0, arg1, *arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawSolidCircle_4(JSDraw* self, b2Vec2* arg0, float arg1, b2Vec2* arg2, b2Color* arg3) {\n  self->DrawSolidCircle(*arg0, arg1, *arg2, *arg3);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawSegment_3(JSDraw* self, b2Vec2* arg0, b2Vec2* arg1, b2Color* arg2) {\n  self->DrawSegment(*arg0, *arg1, *arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw_DrawTransform_1(JSDraw* self, b2Transform* arg0) {\n  self->DrawTransform(*arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_JSDraw___destroy___0(JSDraw* self) {\n  delete self;\n}\n\n// b2WheelJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetLocalAnchorA_0(b2WheelJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetLocalAnchorB_0(b2WheelJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetLocalAxisA_0(b2WheelJoint* self) {\n  return &self->GetLocalAxisA();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetJointTranslation_0(b2WheelJoint* self) {\n  return self->GetJointTranslation();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetJointSpeed_0(b2WheelJoint* self) {\n  return self->GetJointSpeed();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_IsMotorEnabled_0(b2WheelJoint* self) {\n  return self->IsMotorEnabled();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_EnableMotor_1(b2WheelJoint* self, bool arg0) {\n  self->EnableMotor(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_SetMotorSpeed_1(b2WheelJoint* self, float arg0) {\n  self->SetMotorSpeed(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetMotorSpeed_0(b2WheelJoint* self) {\n  return self->GetMotorSpeed();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_SetMaxMotorTorque_1(b2WheelJoint* self, float arg0) {\n  self->SetMaxMotorTorque(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetMaxMotorTorque_0(b2WheelJoint* self) {\n  return self->GetMaxMotorTorque();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetMotorTorque_1(b2WheelJoint* self, float arg0) {\n  return self->GetMotorTorque(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_SetSpringFrequencyHz_1(b2WheelJoint* self, float arg0) {\n  self->SetSpringFrequencyHz(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetSpringFrequencyHz_0(b2WheelJoint* self) {\n  return self->GetSpringFrequencyHz();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_SetSpringDampingRatio_1(b2WheelJoint* self, float arg0) {\n  self->SetSpringDampingRatio(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetSpringDampingRatio_0(b2WheelJoint* self) {\n  return self->GetSpringDampingRatio();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetType_0(b2WheelJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetBodyA_0(b2WheelJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetBodyB_0(b2WheelJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetAnchorA_0(b2WheelJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetAnchorB_0(b2WheelJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetReactionForce_1(b2WheelJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetReactionTorque_1(b2WheelJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetNext_0(b2WheelJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetUserData_0(b2WheelJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_SetUserData_1(b2WheelJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_IsActive_0(b2WheelJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint_GetCollideConnected_0(b2WheelJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2WheelJoint___destroy___0(b2WheelJoint* self) {\n  delete self;\n}\n\n// b2PulleyJoint\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetGroundAnchorA_0(b2PulleyJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetGroundAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetGroundAnchorB_0(b2PulleyJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetGroundAnchorB(), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetLengthA_0(b2PulleyJoint* self) {\n  return self->GetLengthA();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetLengthB_0(b2PulleyJoint* self) {\n  return self->GetLengthB();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetRatio_0(b2PulleyJoint* self) {\n  return self->GetRatio();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetCurrentLengthA_0(b2PulleyJoint* self) {\n  return self->GetCurrentLengthA();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetCurrentLengthB_0(b2PulleyJoint* self) {\n  return self->GetCurrentLengthB();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetType_0(b2PulleyJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetBodyA_0(b2PulleyJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetBodyB_0(b2PulleyJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetAnchorA_0(b2PulleyJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetAnchorB_0(b2PulleyJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetReactionForce_1(b2PulleyJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetReactionTorque_1(b2PulleyJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetNext_0(b2PulleyJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetUserData_0(b2PulleyJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_SetUserData_1(b2PulleyJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_IsActive_0(b2PulleyJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint_GetCollideConnected_0(b2PulleyJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2PulleyJoint___destroy___0(b2PulleyJoint* self) {\n  delete self;\n}\n\n// b2MouseJointDef\n\nb2MouseJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_b2MouseJointDef_0() {\n  return new b2MouseJointDef();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_target_0(b2MouseJointDef* self) {\n  return &self->target;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_target_1(b2MouseJointDef* self, b2Vec2* arg0) {\n  self->target = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_maxForce_0(b2MouseJointDef* self) {\n  return self->maxForce;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_maxForce_1(b2MouseJointDef* self, float arg0) {\n  self->maxForce = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_frequencyHz_0(b2MouseJointDef* self) {\n  return self->frequencyHz;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_frequencyHz_1(b2MouseJointDef* self, float arg0) {\n  self->frequencyHz = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_dampingRatio_0(b2MouseJointDef* self) {\n  return self->dampingRatio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_dampingRatio_1(b2MouseJointDef* self, float arg0) {\n  self->dampingRatio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_type_0(b2MouseJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_type_1(b2MouseJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_userData_0(b2MouseJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_userData_1(b2MouseJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_bodyA_0(b2MouseJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_bodyA_1(b2MouseJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_bodyB_0(b2MouseJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_bodyB_1(b2MouseJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_get_collideConnected_0(b2MouseJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef_set_collideConnected_1(b2MouseJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MouseJointDef___destroy___0(b2MouseJointDef* self) {\n  delete self;\n}\n\n// b2Contact\n\nb2Manifold* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetManifold_0(b2Contact* self) {\n  return self->GetManifold();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetWorldManifold_1(b2Contact* self, b2WorldManifold* arg0) {\n  self->GetWorldManifold(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_IsTouching_0(b2Contact* self) {\n  return self->IsTouching();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_SetEnabled_1(b2Contact* self, bool arg0) {\n  self->SetEnabled(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_IsEnabled_0(b2Contact* self) {\n  return self->IsEnabled();\n}\n\nb2Contact* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetNext_0(b2Contact* self) {\n  return self->GetNext();\n}\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetFixtureA_0(b2Contact* self) {\n  return self->GetFixtureA();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetChildIndexA_0(b2Contact* self) {\n  return self->GetChildIndexA();\n}\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetFixtureB_0(b2Contact* self) {\n  return self->GetFixtureB();\n}\n\nint EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetChildIndexB_0(b2Contact* self) {\n  return self->GetChildIndexB();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_SetFriction_1(b2Contact* self, float arg0) {\n  self->SetFriction(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetFriction_0(b2Contact* self) {\n  return self->GetFriction();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_ResetFriction_0(b2Contact* self) {\n  self->ResetFriction();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_SetRestitution_1(b2Contact* self, float arg0) {\n  self->SetRestitution(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetRestitution_0(b2Contact* self) {\n  return self->GetRestitution();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_ResetRestitution_0(b2Contact* self) {\n  self->ResetRestitution();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_SetTangentSpeed_1(b2Contact* self, float arg0) {\n  self->SetTangentSpeed(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Contact_GetTangentSpeed_0(b2Contact* self) {\n  return self->GetTangentSpeed();\n}\n\n// b2DistanceJointDef\n\nb2DistanceJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_b2DistanceJointDef_0() {\n  return new b2DistanceJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_Initialize_4(b2DistanceJointDef* self, b2Body* arg0, b2Body* arg1, b2Vec2* arg2, b2Vec2* arg3) {\n  self->Initialize(arg0, arg1, *arg2, *arg3);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_localAnchorA_0(b2DistanceJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_localAnchorA_1(b2DistanceJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_localAnchorB_0(b2DistanceJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_localAnchorB_1(b2DistanceJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_length_0(b2DistanceJointDef* self) {\n  return self->length;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_length_1(b2DistanceJointDef* self, float arg0) {\n  self->length = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_frequencyHz_0(b2DistanceJointDef* self) {\n  return self->frequencyHz;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_frequencyHz_1(b2DistanceJointDef* self, float arg0) {\n  self->frequencyHz = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_dampingRatio_0(b2DistanceJointDef* self) {\n  return self->dampingRatio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_dampingRatio_1(b2DistanceJointDef* self, float arg0) {\n  self->dampingRatio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_type_0(b2DistanceJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_type_1(b2DistanceJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_userData_0(b2DistanceJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_userData_1(b2DistanceJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_bodyA_0(b2DistanceJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_bodyA_1(b2DistanceJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_bodyB_0(b2DistanceJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_bodyB_1(b2DistanceJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_get_collideConnected_0(b2DistanceJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef_set_collideConnected_1(b2DistanceJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DistanceJointDef___destroy___0(b2DistanceJointDef* self) {\n  delete self;\n}\n\n// b2Body\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_CreateFixture_1(b2Body* self, b2FixtureDef* arg0) {\n  return self->CreateFixture(arg0);\n}\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_CreateFixture_2(b2Body* self, b2Shape* arg0, float arg1) {\n  return self->CreateFixture(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_DestroyFixture_1(b2Body* self, b2Fixture* arg0) {\n  self->DestroyFixture(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetTransform_2(b2Body* self, b2Vec2* arg0, float arg1) {\n  self->SetTransform(*arg0, arg1);\n}\n\nconst b2Transform* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetTransform_0(b2Body* self) {\n  return &self->GetTransform();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetPosition_0(b2Body* self) {\n  return &self->GetPosition();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetAngle_0(b2Body* self) {\n  return self->GetAngle();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetWorldCenter_0(b2Body* self) {\n  return &self->GetWorldCenter();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLocalCenter_0(b2Body* self) {\n  return &self->GetLocalCenter();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetLinearVelocity_1(b2Body* self, b2Vec2* arg0) {\n  self->SetLinearVelocity(*arg0);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLinearVelocity_0(b2Body* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetLinearVelocity(), &temp);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetAngularVelocity_1(b2Body* self, float arg0) {\n  self->SetAngularVelocity(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetAngularVelocity_0(b2Body* self) {\n  return self->GetAngularVelocity();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ApplyForce_3(b2Body* self, b2Vec2* arg0, b2Vec2* arg1, bool arg2) {\n  self->ApplyForce(*arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ApplyForceToCenter_2(b2Body* self, b2Vec2* arg0, bool arg1) {\n  self->ApplyForceToCenter(*arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ApplyTorque_2(b2Body* self, float arg0, bool arg1) {\n  self->ApplyTorque(arg0, arg1);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ApplyLinearImpulse_3(b2Body* self, b2Vec2* arg0, b2Vec2* arg1, bool arg2) {\n  self->ApplyLinearImpulse(*arg0, *arg1, arg2);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ApplyAngularImpulse_2(b2Body* self, float arg0, bool arg1) {\n  self->ApplyAngularImpulse(arg0, arg1);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetMass_0(b2Body* self) {\n  return self->GetMass();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetInertia_0(b2Body* self) {\n  return self->GetInertia();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetMassData_1(b2Body* self, b2MassData* arg0) {\n  self->GetMassData(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetMassData_1(b2Body* self, b2MassData* arg0) {\n  self->SetMassData(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_ResetMassData_0(b2Body* self) {\n  self->ResetMassData();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetWorldPoint_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetWorldPoint(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetWorldVector_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetWorldVector(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLocalPoint_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetLocalPoint(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLocalVector_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetLocalVector(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLinearVelocityFromWorldPoint_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetLinearVelocityFromWorldPoint(*arg0), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLinearVelocityFromLocalPoint_1(b2Body* self, b2Vec2* arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetLinearVelocityFromLocalPoint(*arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetLinearDamping_0(b2Body* self) {\n  return self->GetLinearDamping();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetLinearDamping_1(b2Body* self, float arg0) {\n  self->SetLinearDamping(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetAngularDamping_0(b2Body* self) {\n  return self->GetAngularDamping();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetAngularDamping_1(b2Body* self, float arg0) {\n  self->SetAngularDamping(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetGravityScale_0(b2Body* self) {\n  return self->GetGravityScale();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetGravityScale_1(b2Body* self, float arg0) {\n  self->SetGravityScale(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetType_1(b2Body* self, b2BodyType arg0) {\n  self->SetType(arg0);\n}\n\nb2BodyType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetType_0(b2Body* self) {\n  return self->GetType();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetBullet_1(b2Body* self, bool arg0) {\n  self->SetBullet(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_IsBullet_0(b2Body* self) {\n  return self->IsBullet();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetSleepingAllowed_1(b2Body* self, bool arg0) {\n  self->SetSleepingAllowed(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_IsSleepingAllowed_0(b2Body* self) {\n  return self->IsSleepingAllowed();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetAwake_1(b2Body* self, bool arg0) {\n  self->SetAwake(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_IsAwake_0(b2Body* self) {\n  return self->IsAwake();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetActive_1(b2Body* self, bool arg0) {\n  self->SetActive(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_IsActive_0(b2Body* self) {\n  return self->IsActive();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetFixedRotation_1(b2Body* self, bool arg0) {\n  self->SetFixedRotation(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_IsFixedRotation_0(b2Body* self) {\n  return self->IsFixedRotation();\n}\n\nb2Fixture* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetFixtureList_0(b2Body* self) {\n  return self->GetFixtureList();\n}\n\nb2JointEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetJointList_0(b2Body* self) {\n  return self->GetJointList();\n}\n\nb2ContactEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetContactList_0(b2Body* self) {\n  return self->GetContactList();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetNext_0(b2Body* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetUserData_0(b2Body* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_SetUserData_1(b2Body* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nb2World* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_GetWorld_0(b2Body* self) {\n  return self->GetWorld();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2Body_Dump_0(b2Body* self) {\n  self->Dump();\n}\n\n// b2FrictionJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetLocalAnchorA_0(b2FrictionJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetLocalAnchorB_0(b2FrictionJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_SetMaxForce_1(b2FrictionJoint* self, float arg0) {\n  self->SetMaxForce(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetMaxForce_0(b2FrictionJoint* self) {\n  return self->GetMaxForce();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_SetMaxTorque_1(b2FrictionJoint* self, float arg0) {\n  self->SetMaxTorque(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetMaxTorque_0(b2FrictionJoint* self) {\n  return self->GetMaxTorque();\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetType_0(b2FrictionJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetBodyA_0(b2FrictionJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetBodyB_0(b2FrictionJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetAnchorA_0(b2FrictionJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetAnchorB_0(b2FrictionJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetReactionForce_1(b2FrictionJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetReactionTorque_1(b2FrictionJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetNext_0(b2FrictionJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetUserData_0(b2FrictionJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_SetUserData_1(b2FrictionJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_IsActive_0(b2FrictionJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint_GetCollideConnected_0(b2FrictionJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2FrictionJoint___destroy___0(b2FrictionJoint* self) {\n  delete self;\n}\n\n// b2DestructionListener\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2DestructionListener___destroy___0(b2DestructionListener* self) {\n  delete self;\n}\n\n// b2GearJointDef\n\nb2GearJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_b2GearJointDef_0() {\n  return new b2GearJointDef();\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_joint1_0(b2GearJointDef* self) {\n  return self->joint1;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_joint1_1(b2GearJointDef* self, b2Joint* arg0) {\n  self->joint1 = arg0;\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_joint2_0(b2GearJointDef* self) {\n  return self->joint2;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_joint2_1(b2GearJointDef* self, b2Joint* arg0) {\n  self->joint2 = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_ratio_0(b2GearJointDef* self) {\n  return self->ratio;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_ratio_1(b2GearJointDef* self, float arg0) {\n  self->ratio = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_type_0(b2GearJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_type_1(b2GearJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_userData_0(b2GearJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_userData_1(b2GearJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_bodyA_0(b2GearJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_bodyA_1(b2GearJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_bodyB_0(b2GearJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_bodyB_1(b2GearJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_get_collideConnected_0(b2GearJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef_set_collideConnected_1(b2GearJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2GearJointDef___destroy___0(b2GearJointDef* self) {\n  delete self;\n}\n\n// b2RevoluteJoint\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetLocalAnchorA_0(b2RevoluteJoint* self) {\n  return &self->GetLocalAnchorA();\n}\n\nconst b2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetLocalAnchorB_0(b2RevoluteJoint* self) {\n  return &self->GetLocalAnchorB();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetReferenceAngle_0(b2RevoluteJoint* self) {\n  return self->GetReferenceAngle();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetJointAngle_0(b2RevoluteJoint* self) {\n  return self->GetJointAngle();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetJointSpeed_0(b2RevoluteJoint* self) {\n  return self->GetJointSpeed();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_IsLimitEnabled_0(b2RevoluteJoint* self) {\n  return self->IsLimitEnabled();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_EnableLimit_1(b2RevoluteJoint* self, bool arg0) {\n  self->EnableLimit(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetLowerLimit_0(b2RevoluteJoint* self) {\n  return self->GetLowerLimit();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetUpperLimit_0(b2RevoluteJoint* self) {\n  return self->GetUpperLimit();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_SetLimits_2(b2RevoluteJoint* self, float arg0, float arg1) {\n  self->SetLimits(arg0, arg1);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_IsMotorEnabled_0(b2RevoluteJoint* self) {\n  return self->IsMotorEnabled();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_EnableMotor_1(b2RevoluteJoint* self, bool arg0) {\n  self->EnableMotor(arg0);\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_SetMotorSpeed_1(b2RevoluteJoint* self, float arg0) {\n  self->SetMotorSpeed(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetMotorSpeed_0(b2RevoluteJoint* self) {\n  return self->GetMotorSpeed();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_SetMaxMotorTorque_1(b2RevoluteJoint* self, float arg0) {\n  self->SetMaxMotorTorque(arg0);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetMaxMotorTorque_0(b2RevoluteJoint* self) {\n  return self->GetMaxMotorTorque();\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetMotorTorque_1(b2RevoluteJoint* self, float arg0) {\n  return self->GetMotorTorque(arg0);\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetType_0(b2RevoluteJoint* self) {\n  return self->GetType();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetBodyA_0(b2RevoluteJoint* self) {\n  return self->GetBodyA();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetBodyB_0(b2RevoluteJoint* self) {\n  return self->GetBodyB();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetAnchorA_0(b2RevoluteJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorA(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetAnchorB_0(b2RevoluteJoint* self) {\n  static b2Vec2 temp;\n  return (temp = self->GetAnchorB(), &temp);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetReactionForce_1(b2RevoluteJoint* self, float arg0) {\n  static b2Vec2 temp;\n  return (temp = self->GetReactionForce(arg0), &temp);\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetReactionTorque_1(b2RevoluteJoint* self, float arg0) {\n  return self->GetReactionTorque(arg0);\n}\n\nb2Joint* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetNext_0(b2RevoluteJoint* self) {\n  return self->GetNext();\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetUserData_0(b2RevoluteJoint* self) {\n  return self->GetUserData();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_SetUserData_1(b2RevoluteJoint* self, void* arg0) {\n  self->SetUserData(arg0);\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_IsActive_0(b2RevoluteJoint* self) {\n  return self->IsActive();\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint_GetCollideConnected_0(b2RevoluteJoint* self) {\n  return self->GetCollideConnected();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RevoluteJoint___destroy___0(b2RevoluteJoint* self) {\n  delete self;\n}\n\n// b2ContactEdge\n\nb2ContactEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_b2ContactEdge_0() {\n  return new b2ContactEdge();\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_get_other_0(b2ContactEdge* self) {\n  return self->other;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_set_other_1(b2ContactEdge* self, b2Body* arg0) {\n  self->other = arg0;\n}\n\nb2Contact* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_get_contact_0(b2ContactEdge* self) {\n  return self->contact;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_set_contact_1(b2ContactEdge* self, b2Contact* arg0) {\n  self->contact = arg0;\n}\n\nb2ContactEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_get_prev_0(b2ContactEdge* self) {\n  return self->prev;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_set_prev_1(b2ContactEdge* self, b2ContactEdge* arg0) {\n  self->prev = arg0;\n}\n\nb2ContactEdge* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_get_next_0(b2ContactEdge* self) {\n  return self->next;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge_set_next_1(b2ContactEdge* self, b2ContactEdge* arg0) {\n  self->next = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2ContactEdge___destroy___0(b2ContactEdge* self) {\n  delete self;\n}\n\n// b2RopeJointDef\n\nb2RopeJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_b2RopeJointDef_0() {\n  return new b2RopeJointDef();\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_localAnchorA_0(b2RopeJointDef* self) {\n  return &self->localAnchorA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_localAnchorA_1(b2RopeJointDef* self, b2Vec2* arg0) {\n  self->localAnchorA = *arg0;\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_localAnchorB_0(b2RopeJointDef* self) {\n  return &self->localAnchorB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_localAnchorB_1(b2RopeJointDef* self, b2Vec2* arg0) {\n  self->localAnchorB = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_maxLength_0(b2RopeJointDef* self) {\n  return self->maxLength;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_maxLength_1(b2RopeJointDef* self, float arg0) {\n  self->maxLength = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_type_0(b2RopeJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_type_1(b2RopeJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_userData_0(b2RopeJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_userData_1(b2RopeJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_bodyA_0(b2RopeJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_bodyA_1(b2RopeJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_bodyB_0(b2RopeJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_bodyB_1(b2RopeJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_get_collideConnected_0(b2RopeJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef_set_collideConnected_1(b2RopeJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2RopeJointDef___destroy___0(b2RopeJointDef* self) {\n  delete self;\n}\n\n// b2MotorJointDef\n\nb2MotorJointDef* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_b2MotorJointDef_0() {\n  return new b2MotorJointDef();\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_Initialize_2(b2MotorJointDef* self, b2Body* arg0, b2Body* arg1) {\n  self->Initialize(arg0, arg1);\n}\n\nb2Vec2* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_get_linearOffset_0(b2MotorJointDef* self) {\n  return &self->linearOffset;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_set_linearOffset_1(b2MotorJointDef* self, b2Vec2* arg0) {\n  self->linearOffset = *arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_get_angularOffset_0(b2MotorJointDef* self) {\n  return self->angularOffset;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_set_angularOffset_1(b2MotorJointDef* self, float arg0) {\n  self->angularOffset = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_get_maxForce_0(b2MotorJointDef* self) {\n  return self->maxForce;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_set_maxForce_1(b2MotorJointDef* self, float arg0) {\n  self->maxForce = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_get_maxTorque_0(b2MotorJointDef* self) {\n  return self->maxTorque;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_set_maxTorque_1(b2MotorJointDef* self, float arg0) {\n  self->maxTorque = arg0;\n}\n\nfloat EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_get_correctionFactor_0(b2MotorJointDef* self) {\n  return self->correctionFactor;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_set_correctionFactor_1(b2MotorJointDef* self, float arg0) {\n  self->correctionFactor = arg0;\n}\n\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_get_type_0(b2MotorJointDef* self) {\n  return self->type;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_set_type_1(b2MotorJointDef* self, b2JointType arg0) {\n  self->type = arg0;\n}\n\nvoid* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_get_userData_0(b2MotorJointDef* self) {\n  return self->userData;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_set_userData_1(b2MotorJointDef* self, void* arg0) {\n  self->userData = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_get_bodyA_0(b2MotorJointDef* self) {\n  return self->bodyA;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_set_bodyA_1(b2MotorJointDef* self, b2Body* arg0) {\n  self->bodyA = arg0;\n}\n\nb2Body* EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_get_bodyB_0(b2MotorJointDef* self) {\n  return self->bodyB;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_set_bodyB_1(b2MotorJointDef* self, b2Body* arg0) {\n  self->bodyB = arg0;\n}\n\nbool EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_get_collideConnected_0(b2MotorJointDef* self) {\n  return self->collideConnected;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef_set_collideConnected_1(b2MotorJointDef* self, bool arg0) {\n  self->collideConnected = arg0;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE emscripten_bind_b2MotorJointDef___destroy___0(b2MotorJointDef* self) {\n  delete self;\n}\n\n// b2ShapeType\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ShapeType_e_circle() {\n  return b2Shape::e_circle;\n}\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ShapeType_e_edge() {\n  return b2Shape::e_edge;\n}\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ShapeType_e_polygon() {\n  return b2Shape::e_polygon;\n}\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ShapeType_e_chain() {\n  return b2Shape::e_chain;\n}\nb2ShapeType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ShapeType_e_typeCount() {\n  return b2Shape::e_typeCount;\n}\n\n// b2JointType\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_unknownJoint() {\n  return e_unknownJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_revoluteJoint() {\n  return e_revoluteJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_prismaticJoint() {\n  return e_prismaticJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_distanceJoint() {\n  return e_distanceJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_pulleyJoint() {\n  return e_pulleyJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_mouseJoint() {\n  return e_mouseJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_gearJoint() {\n  return e_gearJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_wheelJoint() {\n  return e_wheelJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_weldJoint() {\n  return e_weldJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_frictionJoint() {\n  return e_frictionJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_ropeJoint() {\n  return e_ropeJoint;\n}\nb2JointType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2JointType_e_motorJoint() {\n  return e_motorJoint;\n}\n\n// b2LimitState\nb2LimitState EMSCRIPTEN_KEEPALIVE emscripten_enum_b2LimitState_e_inactiveLimit() {\n  return e_inactiveLimit;\n}\nb2LimitState EMSCRIPTEN_KEEPALIVE emscripten_enum_b2LimitState_e_atLowerLimit() {\n  return e_atLowerLimit;\n}\nb2LimitState EMSCRIPTEN_KEEPALIVE emscripten_enum_b2LimitState_e_atUpperLimit() {\n  return e_atUpperLimit;\n}\nb2LimitState EMSCRIPTEN_KEEPALIVE emscripten_enum_b2LimitState_e_equalLimits() {\n  return e_equalLimits;\n}\n\n// b2ManifoldType\nb2ManifoldType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ManifoldType_e_circles() {\n  return b2Manifold::e_circles;\n}\nb2ManifoldType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ManifoldType_e_faceA() {\n  return b2Manifold::e_faceA;\n}\nb2ManifoldType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ManifoldType_e_faceB() {\n  return b2Manifold::e_faceB;\n}\n\n// b2BodyType\nb2BodyType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2BodyType_b2_staticBody() {\n  return b2_staticBody;\n}\nb2BodyType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2BodyType_b2_kinematicBody() {\n  return b2_kinematicBody;\n}\nb2BodyType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2BodyType_b2_dynamicBody() {\n  return b2_dynamicBody;\n}\n\n// b2DrawFlag\nb2DrawFlag EMSCRIPTEN_KEEPALIVE emscripten_enum_b2DrawFlag_e_shapeBit() {\n  return b2Draw::e_shapeBit;\n}\nb2DrawFlag EMSCRIPTEN_KEEPALIVE emscripten_enum_b2DrawFlag_e_jointBit() {\n  return b2Draw::e_jointBit;\n}\nb2DrawFlag EMSCRIPTEN_KEEPALIVE emscripten_enum_b2DrawFlag_e_aabbBit() {\n  return b2Draw::e_aabbBit;\n}\nb2DrawFlag EMSCRIPTEN_KEEPALIVE emscripten_enum_b2DrawFlag_e_pairBit() {\n  return b2Draw::e_pairBit;\n}\nb2DrawFlag EMSCRIPTEN_KEEPALIVE emscripten_enum_b2DrawFlag_e_centerOfMassBit() {\n  return b2Draw::e_centerOfMassBit;\n}\n\n// b2ContactFeatureType\nb2ContactFeatureType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ContactFeatureType_e_vertex() {\n  return b2ContactFeature::e_vertex;\n}\nb2ContactFeatureType EMSCRIPTEN_KEEPALIVE emscripten_enum_b2ContactFeatureType_e_face() {\n  return b2ContactFeature::e_face;\n}\n\n}\n\n","/*\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_JOINT_H\n#define B2_JOINT_H\n\n#include <Box2D/Common/b2Math.h>\n\nclass b2Body;\nclass b2Joint;\nstruct b2SolverData;\nclass b2BlockAllocator;\n\nenum b2JointType\n{\n\te_unknownJoint,\n\te_revoluteJoint,\n\te_prismaticJoint,\n\te_distanceJoint,\n\te_pulleyJoint,\n\te_mouseJoint,\n\te_gearJoint,\n\te_wheelJoint,\n    e_weldJoint,\n\te_frictionJoint,\n\te_ropeJoint,\n\te_motorJoint\n};\n\nenum b2LimitState\n{\n\te_inactiveLimit,\n\te_atLowerLimit,\n\te_atUpperLimit,\n\te_equalLimits\n};\n\nstruct b2Jacobian\n{\n\tb2Vec2 linear;\n\tfloat32 angularA;\n\tfloat32 angularB;\n};\n\n/// A joint edge is used to connect bodies and joints together\n/// in a joint graph where each body is a node and each joint\n/// is an edge. A joint edge belongs to a doubly linked list\n/// maintained in each attached body. Each joint has two joint\n/// nodes, one for each attached body.\nstruct b2JointEdge\n{\n\tb2Body* other;\t\t\t///< provides quick access to the other body attached.\n\tb2Joint* joint;\t\t\t///< the joint\n\tb2JointEdge* prev;\t\t///< the previous joint edge in the body's joint list\n\tb2JointEdge* next;\t\t///< the next joint edge in the body's joint list\n};\n\n/// Joint definitions are used to construct joints.\nstruct b2JointDef\n{\n\tb2JointDef()\n\t{\n\t\ttype = e_unknownJoint;\n\t\tuserData = NULL;\n\t\tbodyA = NULL;\n\t\tbodyB = NULL;\n\t\tcollideConnected = false;\n\t}\n\n\t/// The joint type is set automatically for concrete joint types.\n\tb2JointType type;\n\n\t/// Use this to attach application specific data to your joints.\n\tvoid* userData;\n\n\t/// The first attached body.\n\tb2Body* bodyA;\n\n\t/// The second attached body.\n\tb2Body* bodyB;\n\n\t/// Set this flag to true if the attached bodies should collide.\n\tbool collideConnected;\n};\n\n/// The base joint class. Joints are used to constraint two bodies together in\n/// various fashions. Some joints also feature limits and motors.\nclass b2Joint\n{\npublic:\n\n\t/// Get the type of the concrete joint.\n\tb2JointType GetType() const;\n\n\t/// Get the first body attached to this joint.\n\tb2Body* GetBodyA();\n\n\t/// Get the second body attached to this joint.\n\tb2Body* GetBodyB();\n\n\t/// Get the anchor point on bodyA in world coordinates.\n\tvirtual b2Vec2 GetAnchorA() const = 0;\n\n\t/// Get the anchor point on bodyB in world coordinates.\n\tvirtual b2Vec2 GetAnchorB() const = 0;\n\n\t/// Get the reaction force on bodyB at the joint anchor in Newtons.\n\tvirtual b2Vec2 GetReactionForce(float32 inv_dt) const = 0;\n\n\t/// Get the reaction torque on bodyB in N*m.\n\tvirtual float32 GetReactionTorque(float32 inv_dt) const = 0;\n\n\t/// Get the next joint the world joint list.\n\tb2Joint* GetNext();\n\tconst b2Joint* GetNext() const;\n\n\t/// Get the user data pointer.\n\tvoid* GetUserData() const;\n\n\t/// Set the user data pointer.\n\tvoid SetUserData(void* data);\n\n\t/// Short-cut function to determine if either body is inactive.\n\tbool IsActive() const;\n\n\t/// Get collide connected.\n\t/// Note: modifying the collide connect flag won't work correctly because\n\t/// the flag is only checked when fixture AABBs begin to overlap.\n\tbool GetCollideConnected() const;\n\n\t/// Dump this joint to the log file.\n\tvirtual void Dump() { b2Log(\"// Dump is not supported for this joint type.\\n\"); }\n\n\t/// Shift the origin for any points stored in world coordinates.\n\tvirtual void ShiftOrigin(const b2Vec2& newOrigin) { B2_NOT_USED(newOrigin);  }\n\nprotected:\n\tfriend class b2World;\n\tfriend class b2Body;\n\tfriend class b2Island;\n\tfriend class b2GearJoint;\n\n\tstatic b2Joint* Create(const b2JointDef* def, b2BlockAllocator* allocator);\n\tstatic void Destroy(b2Joint* joint, b2BlockAllocator* allocator);\n\n\tb2Joint(const b2JointDef* def);\n\tvirtual ~b2Joint() {}\n\n\tvirtual void InitVelocityConstraints(const b2SolverData& data) = 0;\n\tvirtual void SolveVelocityConstraints(const b2SolverData& data) = 0;\n\n\t// This returns true if the position errors are within tolerance.\n\tvirtual bool SolvePositionConstraints(const b2SolverData& data) = 0;\n\n\tb2JointType m_type;\n\tb2Joint* m_prev;\n\tb2Joint* m_next;\n\tb2JointEdge m_edgeA;\n\tb2JointEdge m_edgeB;\n\tb2Body* m_bodyA;\n\tb2Body* m_bodyB;\n\n\tint32 m_index;\n\n\tbool m_islandFlag;\n\tbool m_collideConnected;\n\n\tvoid* m_userData;\n};\n\ninline b2JointType b2Joint::GetType() const\n{\n\treturn m_type;\n}\n\ninline b2Body* b2Joint::GetBodyA()\n{\n\treturn m_bodyA;\n}\n\ninline b2Body* b2Joint::GetBodyB()\n{\n\treturn m_bodyB;\n}\n\ninline b2Joint* b2Joint::GetNext()\n{\n\treturn m_next;\n}\n\ninline const b2Joint* b2Joint::GetNext() const\n{\n\treturn m_next;\n}\n\ninline void* b2Joint::GetUserData() const\n{\n\treturn m_userData;\n}\n\ninline void b2Joint::SetUserData(void* data)\n{\n\tm_userData = data;\n}\n\ninline bool b2Joint::GetCollideConnected() const\n{\n\treturn m_collideConnected;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_MATH_H\n#define B2_MATH_H\n\n#include <Box2D/Common/b2Settings.h>\n#include <math.h>\n\n/// This function is used to ensure that a floating point number is not a NaN or infinity.\ninline bool b2IsValid(float32 x)\n{\n\tint32 ix = *reinterpret_cast<int32*>(&x);\n\treturn (ix & 0x7f800000) != 0x7f800000;\n}\n\n/// This is a approximate yet fast inverse square-root.\ninline float32 b2InvSqrt(float32 x)\n{\n\tunion\n\t{\n\t\tfloat32 x;\n\t\tint32 i;\n\t} convert;\n\n\tconvert.x = x;\n\tfloat32 xhalf = 0.5f * x;\n\tconvert.i = 0x5f3759df - (convert.i >> 1);\n\tx = convert.x;\n\tx = x * (1.5f - xhalf * x * x);\n\treturn x;\n}\n\n#define\tb2Sqrt(x)\tsqrtf(x)\n#define\tb2Atan2(y, x)\tatan2f(y, x)\n\n/// A 2D column vector.\nstruct b2Vec2\n{\n\t/// Default constructor does nothing (for performance).\n\tb2Vec2() {}\n\n\t/// Construct using coordinates.\n\tb2Vec2(float32 x, float32 y) : x(x), y(y) {}\n\n\t/// Set this vector to all zeros.\n\tvoid SetZero() { x = 0.0f; y = 0.0f; }\n\n\t/// Set this vector to some specified coordinates.\n\tvoid Set(float32 x_, float32 y_) { x = x_; y = y_; }\n\n\t/// Negate this vector.\n\tb2Vec2 operator -() const { b2Vec2 v; v.Set(-x, -y); return v; }\n\t\n\t/// Read from and indexed element.\n\tfloat32 operator () (int32 i) const\n\t{\n\t\treturn (&x)[i];\n\t}\n\n\t/// Write to an indexed element.\n\tfloat32& operator () (int32 i)\n\t{\n\t\treturn (&x)[i];\n\t}\n\n\t/// Add a vector to this vector.\n\tvoid operator += (const b2Vec2& v)\n\t{\n\t\tx += v.x; y += v.y;\n\t}\n\t\n\t/// Subtract a vector from this vector.\n\tvoid operator -= (const b2Vec2& v)\n\t{\n\t\tx -= v.x; y -= v.y;\n\t}\n\n\t/// Multiply this vector by a scalar.\n\tvoid operator *= (float32 a)\n\t{\n\t\tx *= a; y *= a;\n\t}\n\n\t/// Get the length of this vector (the norm).\n\tfloat32 Length() const\n\t{\n\t\treturn b2Sqrt(x * x + y * y);\n\t}\n\n\t/// Get the length squared. For performance, use this instead of\n\t/// b2Vec2::Length (if possible).\n\tfloat32 LengthSquared() const\n\t{\n\t\treturn x * x + y * y;\n\t}\n\n\t/// Convert this vector into a unit vector. Returns the length.\n\tfloat32 Normalize()\n\t{\n\t\tfloat32 length = Length();\n\t\tif (length < b2_epsilon)\n\t\t{\n\t\t\treturn 0.0f;\n\t\t}\n\t\tfloat32 invLength = 1.0f / length;\n\t\tx *= invLength;\n\t\ty *= invLength;\n\n\t\treturn length;\n\t}\n\n\t/// Does this vector contain finite coordinates?\n\tbool IsValid() const\n\t{\n\t\treturn b2IsValid(x) && b2IsValid(y);\n\t}\n\n\t/// Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\n\tb2Vec2 Skew() const\n\t{\n\t\treturn b2Vec2(-y, x);\n\t}\n\n\tfloat32 x, y;\n};\n\n/// A 2D column vector with 3 elements.\nstruct b2Vec3\n{\n\t/// Default constructor does nothing (for performance).\n\tb2Vec3() {}\n\n\t/// Construct using coordinates.\n\tb2Vec3(float32 x, float32 y, float32 z) : x(x), y(y), z(z) {}\n\n\t/// Set this vector to all zeros.\n\tvoid SetZero() { x = 0.0f; y = 0.0f; z = 0.0f; }\n\n\t/// Set this vector to some specified coordinates.\n\tvoid Set(float32 x_, float32 y_, float32 z_) { x = x_; y = y_; z = z_; }\n\n\t/// Negate this vector.\n\tb2Vec3 operator -() const { b2Vec3 v; v.Set(-x, -y, -z); return v; }\n\n\t/// Add a vector to this vector.\n\tvoid operator += (const b2Vec3& v)\n\t{\n\t\tx += v.x; y += v.y; z += v.z;\n\t}\n\n\t/// Subtract a vector from this vector.\n\tvoid operator -= (const b2Vec3& v)\n\t{\n\t\tx -= v.x; y -= v.y; z -= v.z;\n\t}\n\n\t/// Multiply this vector by a scalar.\n\tvoid operator *= (float32 s)\n\t{\n\t\tx *= s; y *= s; z *= s;\n\t}\n\n\tfloat32 x, y, z;\n};\n\n/// A 2-by-2 matrix. Stored in column-major order.\nstruct b2Mat22\n{\n\t/// The default constructor does nothing (for performance).\n\tb2Mat22() {}\n\n\t/// Construct this matrix using columns.\n\tb2Mat22(const b2Vec2& c1, const b2Vec2& c2)\n\t{\n\t\tex = c1;\n\t\tey = c2;\n\t}\n\n\t/// Construct this matrix using scalars.\n\tb2Mat22(float32 a11, float32 a12, float32 a21, float32 a22)\n\t{\n\t\tex.x = a11; ex.y = a21;\n\t\tey.x = a12; ey.y = a22;\n\t}\n\n\t/// Initialize this matrix using columns.\n\tvoid Set(const b2Vec2& c1, const b2Vec2& c2)\n\t{\n\t\tex = c1;\n\t\tey = c2;\n\t}\n\n\t/// Set this to the identity matrix.\n\tvoid SetIdentity()\n\t{\n\t\tex.x = 1.0f; ey.x = 0.0f;\n\t\tex.y = 0.0f; ey.y = 1.0f;\n\t}\n\n\t/// Set this matrix to all zeros.\n\tvoid SetZero()\n\t{\n\t\tex.x = 0.0f; ey.x = 0.0f;\n\t\tex.y = 0.0f; ey.y = 0.0f;\n\t}\n\n\tb2Mat22 GetInverse() const\n\t{\n\t\tfloat32 a = ex.x, b = ey.x, c = ex.y, d = ey.y;\n\t\tb2Mat22 B;\n\t\tfloat32 det = a * d - b * c;\n\t\tif (det != 0.0f)\n\t\t{\n\t\t\tdet = 1.0f / det;\n\t\t}\n\t\tB.ex.x =  det * d;\tB.ey.x = -det * b;\n\t\tB.ex.y = -det * c;\tB.ey.y =  det * a;\n\t\treturn B;\n\t}\n\n\t/// Solve A * x = b, where b is a column vector. This is more efficient\n\t/// than computing the inverse in one-shot cases.\n\tb2Vec2 Solve(const b2Vec2& b) const\n\t{\n\t\tfloat32 a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;\n\t\tfloat32 det = a11 * a22 - a12 * a21;\n\t\tif (det != 0.0f)\n\t\t{\n\t\t\tdet = 1.0f / det;\n\t\t}\n\t\tb2Vec2 x;\n\t\tx.x = det * (a22 * b.x - a12 * b.y);\n\t\tx.y = det * (a11 * b.y - a21 * b.x);\n\t\treturn x;\n\t}\n\n\tb2Vec2 ex, ey;\n};\n\n/// A 3-by-3 matrix. Stored in column-major order.\nstruct b2Mat33\n{\n\t/// The default constructor does nothing (for performance).\n\tb2Mat33() {}\n\n\t/// Construct this matrix using columns.\n\tb2Mat33(const b2Vec3& c1, const b2Vec3& c2, const b2Vec3& c3)\n\t{\n\t\tex = c1;\n\t\tey = c2;\n\t\tez = c3;\n\t}\n\n\t/// Set this matrix to all zeros.\n\tvoid SetZero()\n\t{\n\t\tex.SetZero();\n\t\tey.SetZero();\n\t\tez.SetZero();\n\t}\n\n\t/// Solve A * x = b, where b is a column vector. This is more efficient\n\t/// than computing the inverse in one-shot cases.\n\tb2Vec3 Solve33(const b2Vec3& b) const;\n\n\t/// Solve A * x = b, where b is a column vector. This is more efficient\n\t/// than computing the inverse in one-shot cases. Solve only the upper\n\t/// 2-by-2 matrix equation.\n\tb2Vec2 Solve22(const b2Vec2& b) const;\n\n\t/// Get the inverse of this matrix as a 2-by-2.\n\t/// Returns the zero matrix if singular.\n\tvoid GetInverse22(b2Mat33* M) const;\n\n\t/// Get the symmetric inverse of this matrix as a 3-by-3.\n\t/// Returns the zero matrix if singular.\n\tvoid GetSymInverse33(b2Mat33* M) const;\n\n\tb2Vec3 ex, ey, ez;\n};\n\n/// Rotation\nstruct b2Rot\n{\n\tb2Rot() {}\n\n\t/// Initialize from an angle in radians\n\texplicit b2Rot(float32 angle)\n\t{\n\t\t/// TODO_ERIN optimize\n\t\ts = sinf(angle);\n\t\tc = cosf(angle);\n\t}\n\n\t/// Set using an angle in radians.\n\tvoid Set(float32 angle)\n\t{\n\t\t/// TODO_ERIN optimize\n\t\ts = sinf(angle);\n\t\tc = cosf(angle);\n\t}\n\n\t/// Set to the identity rotation\n\tvoid SetIdentity()\n\t{\n\t\ts = 0.0f;\n\t\tc = 1.0f;\n\t}\n\n\t/// Get the angle in radians\n\tfloat32 GetAngle() const\n\t{\n\t\treturn b2Atan2(s, c);\n\t}\n\n\t/// Get the x-axis\n\tb2Vec2 GetXAxis() const\n\t{\n\t\treturn b2Vec2(c, s);\n\t}\n\n\t/// Get the u-axis\n\tb2Vec2 GetYAxis() const\n\t{\n\t\treturn b2Vec2(-s, c);\n\t}\n\n\t/// Sine and cosine\n\tfloat32 s, c;\n};\n\n/// A transform contains translation and rotation. It is used to represent\n/// the position and orientation of rigid frames.\nstruct b2Transform\n{\n\t/// The default constructor does nothing.\n\tb2Transform() {}\n\n\t/// Initialize using a position vector and a rotation.\n\tb2Transform(const b2Vec2& position, const b2Rot& rotation) : p(position), q(rotation) {}\n\n\t/// Set this to the identity transform.\n\tvoid SetIdentity()\n\t{\n\t\tp.SetZero();\n\t\tq.SetIdentity();\n\t}\n\n\t/// Set this based on the position and angle.\n\tvoid Set(const b2Vec2& position, float32 angle)\n\t{\n\t\tp = position;\n\t\tq.Set(angle);\n\t}\n\n\tb2Vec2 p;\n\tb2Rot q;\n};\n\n/// This describes the motion of a body/shape for TOI computation.\n/// Shapes are defined with respect to the body origin, which may\n/// no coincide with the center of mass. However, to support dynamics\n/// we must interpolate the center of mass position.\nstruct b2Sweep\n{\n\t/// Get the interpolated transform at a specific time.\n\t/// @param beta is a factor in [0,1], where 0 indicates alpha0.\n\tvoid GetTransform(b2Transform* xfb, float32 beta) const;\n\n\t/// Advance the sweep forward, yielding a new initial state.\n\t/// @param alpha the new initial time.\n\tvoid Advance(float32 alpha);\n\n\t/// Normalize the angles.\n\tvoid Normalize();\n\n\tb2Vec2 localCenter;\t///< local center of mass position\n\tb2Vec2 c0, c;\t\t///< center world positions\n\tfloat32 a0, a;\t\t///< world angles\n\n\t/// Fraction of the current time step in the range [0,1]\n\t/// c0 and a0 are the positions at alpha0.\n\tfloat32 alpha0;\n};\n\n/// Useful constant\nextern const b2Vec2 b2Vec2_zero;\n\n/// Perform the dot product on two vectors.\ninline float32 b2Dot(const b2Vec2& a, const b2Vec2& b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n/// Perform the cross product on two vectors. In 2D this produces a scalar.\ninline float32 b2Cross(const b2Vec2& a, const b2Vec2& b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n/// Perform the cross product on a vector and a scalar. In 2D this produces\n/// a vector.\ninline b2Vec2 b2Cross(const b2Vec2& a, float32 s)\n{\n\treturn b2Vec2(s * a.y, -s * a.x);\n}\n\n/// Perform the cross product on a scalar and a vector. In 2D this produces\n/// a vector.\ninline b2Vec2 b2Cross(float32 s, const b2Vec2& a)\n{\n\treturn b2Vec2(-s * a.y, s * a.x);\n}\n\n/// Multiply a matrix times a vector. If a rotation matrix is provided,\n/// then this transforms the vector from one frame to another.\ninline b2Vec2 b2Mul(const b2Mat22& A, const b2Vec2& v)\n{\n\treturn b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);\n}\n\n/// Multiply a matrix transpose times a vector. If a rotation matrix is provided,\n/// then this transforms the vector from one frame to another (inverse transform).\ninline b2Vec2 b2MulT(const b2Mat22& A, const b2Vec2& v)\n{\n\treturn b2Vec2(b2Dot(v, A.ex), b2Dot(v, A.ey));\n}\n\n/// Add two vectors component-wise.\ninline b2Vec2 operator + (const b2Vec2& a, const b2Vec2& b)\n{\n\treturn b2Vec2(a.x + b.x, a.y + b.y);\n}\n\n/// Subtract two vectors component-wise.\ninline b2Vec2 operator - (const b2Vec2& a, const b2Vec2& b)\n{\n\treturn b2Vec2(a.x - b.x, a.y - b.y);\n}\n\ninline b2Vec2 operator * (float32 s, const b2Vec2& a)\n{\n\treturn b2Vec2(s * a.x, s * a.y);\n}\n\ninline bool operator == (const b2Vec2& a, const b2Vec2& b)\n{\n\treturn a.x == b.x && a.y == b.y;\n}\n\ninline float32 b2Distance(const b2Vec2& a, const b2Vec2& b)\n{\n\tb2Vec2 c = a - b;\n\treturn c.Length();\n}\n\ninline float32 b2DistanceSquared(const b2Vec2& a, const b2Vec2& b)\n{\n\tb2Vec2 c = a - b;\n\treturn b2Dot(c, c);\n}\n\ninline b2Vec3 operator * (float32 s, const b2Vec3& a)\n{\n\treturn b2Vec3(s * a.x, s * a.y, s * a.z);\n}\n\n/// Add two vectors component-wise.\ninline b2Vec3 operator + (const b2Vec3& a, const b2Vec3& b)\n{\n\treturn b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);\n}\n\n/// Subtract two vectors component-wise.\ninline b2Vec3 operator - (const b2Vec3& a, const b2Vec3& b)\n{\n\treturn b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);\n}\n\n/// Perform the dot product on two vectors.\ninline float32 b2Dot(const b2Vec3& a, const b2Vec3& b)\n{\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\n/// Perform the cross product on two vectors.\ninline b2Vec3 b2Cross(const b2Vec3& a, const b2Vec3& b)\n{\n\treturn b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}\n\ninline b2Mat22 operator + (const b2Mat22& A, const b2Mat22& B)\n{\n\treturn b2Mat22(A.ex + B.ex, A.ey + B.ey);\n}\n\n// A * B\ninline b2Mat22 b2Mul(const b2Mat22& A, const b2Mat22& B)\n{\n\treturn b2Mat22(b2Mul(A, B.ex), b2Mul(A, B.ey));\n}\n\n// A^T * B\ninline b2Mat22 b2MulT(const b2Mat22& A, const b2Mat22& B)\n{\n\tb2Vec2 c1(b2Dot(A.ex, B.ex), b2Dot(A.ey, B.ex));\n\tb2Vec2 c2(b2Dot(A.ex, B.ey), b2Dot(A.ey, B.ey));\n\treturn b2Mat22(c1, c2);\n}\n\n/// Multiply a matrix times a vector.\ninline b2Vec3 b2Mul(const b2Mat33& A, const b2Vec3& v)\n{\n\treturn v.x * A.ex + v.y * A.ey + v.z * A.ez;\n}\n\n/// Multiply a matrix times a vector.\ninline b2Vec2 b2Mul22(const b2Mat33& A, const b2Vec2& v)\n{\n\treturn b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);\n}\n\n/// Multiply two rotations: q * r\ninline b2Rot b2Mul(const b2Rot& q, const b2Rot& r)\n{\n\t// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n\t// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]\n\t// s = qs * rc + qc * rs\n\t// c = qc * rc - qs * rs\n\tb2Rot qr;\n\tqr.s = q.s * r.c + q.c * r.s;\n\tqr.c = q.c * r.c - q.s * r.s;\n\treturn qr;\n}\n\n/// Transpose multiply two rotations: qT * r\ninline b2Rot b2MulT(const b2Rot& q, const b2Rot& r)\n{\n\t// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n\t// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]\n\t// s = qc * rs - qs * rc\n\t// c = qc * rc + qs * rs\n\tb2Rot qr;\n\tqr.s = q.c * r.s - q.s * r.c;\n\tqr.c = q.c * r.c + q.s * r.s;\n\treturn qr;\n}\n\n/// Rotate a vector\ninline b2Vec2 b2Mul(const b2Rot& q, const b2Vec2& v)\n{\n\treturn b2Vec2(q.c * v.x - q.s * v.y, q.s * v.x + q.c * v.y);\n}\n\n/// Inverse rotate a vector\ninline b2Vec2 b2MulT(const b2Rot& q, const b2Vec2& v)\n{\n\treturn b2Vec2(q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y);\n}\n\ninline b2Vec2 b2Mul(const b2Transform& T, const b2Vec2& v)\n{\n\tfloat32 x = (T.q.c * v.x - T.q.s * v.y) + T.p.x;\n\tfloat32 y = (T.q.s * v.x + T.q.c * v.y) + T.p.y;\n\n\treturn b2Vec2(x, y);\n}\n\ninline b2Vec2 b2MulT(const b2Transform& T, const b2Vec2& v)\n{\n\tfloat32 px = v.x - T.p.x;\n\tfloat32 py = v.y - T.p.y;\n\tfloat32 x = (T.q.c * px + T.q.s * py);\n\tfloat32 y = (-T.q.s * px + T.q.c * py);\n\n\treturn b2Vec2(x, y);\n}\n\n// v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p\n//    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p\ninline b2Transform b2Mul(const b2Transform& A, const b2Transform& B)\n{\n\tb2Transform C;\n\tC.q = b2Mul(A.q, B.q);\n\tC.p = b2Mul(A.q, B.p) + A.p;\n\treturn C;\n}\n\n// v2 = A.q' * (B.q * v1 + B.p - A.p)\n//    = A.q' * B.q * v1 + A.q' * (B.p - A.p)\ninline b2Transform b2MulT(const b2Transform& A, const b2Transform& B)\n{\n\tb2Transform C;\n\tC.q = b2MulT(A.q, B.q);\n\tC.p = b2MulT(A.q, B.p - A.p);\n\treturn C;\n}\n\ntemplate <typename T>\ninline T b2Abs(T a)\n{\n\treturn a > T(0) ? a : -a;\n}\n\ninline b2Vec2 b2Abs(const b2Vec2& a)\n{\n\treturn b2Vec2(b2Abs(a.x), b2Abs(a.y));\n}\n\ninline b2Mat22 b2Abs(const b2Mat22& A)\n{\n\treturn b2Mat22(b2Abs(A.ex), b2Abs(A.ey));\n}\n\ntemplate <typename T>\ninline T b2Min(T a, T b)\n{\n\treturn a < b ? a : b;\n}\n\ninline b2Vec2 b2Min(const b2Vec2& a, const b2Vec2& b)\n{\n\treturn b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));\n}\n\ntemplate <typename T>\ninline T b2Max(T a, T b)\n{\n\treturn a > b ? a : b;\n}\n\ninline b2Vec2 b2Max(const b2Vec2& a, const b2Vec2& b)\n{\n\treturn b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));\n}\n\ntemplate <typename T>\ninline T b2Clamp(T a, T low, T high)\n{\n\treturn b2Max(low, b2Min(a, high));\n}\n\ninline b2Vec2 b2Clamp(const b2Vec2& a, const b2Vec2& low, const b2Vec2& high)\n{\n\treturn b2Max(low, b2Min(a, high));\n}\n\ntemplate<typename T> inline void b2Swap(T& a, T& b)\n{\n\tT tmp = a;\n\ta = b;\n\tb = tmp;\n}\n\n/// \"Next Largest Power of 2\n/// Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm\n/// that recursively \"folds\" the upper bits into the lower bits. This process yields a bit vector with\n/// the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next\n/// largest power of 2. For a 32-bit value:\"\ninline uint32 b2NextPowerOfTwo(uint32 x)\n{\n\tx |= (x >> 1);\n\tx |= (x >> 2);\n\tx |= (x >> 4);\n\tx |= (x >> 8);\n\tx |= (x >> 16);\n\treturn x + 1;\n}\n\ninline bool b2IsPowerOfTwo(uint32 x)\n{\n\tbool result = x > 0 && (x & (x - 1)) == 0;\n\treturn result;\n}\n\ninline void b2Sweep::GetTransform(b2Transform* xf, float32 beta) const\n{\n\txf->p = (1.0f - beta) * c0 + beta * c;\n\tfloat32 angle = (1.0f - beta) * a0 + beta * a;\n\txf->q.Set(angle);\n\n\t// Shift to origin\n\txf->p -= b2Mul(xf->q, localCenter);\n}\n\ninline void b2Sweep::Advance(float32 alpha)\n{\n\tb2Assert(alpha0 < 1.0f);\n\tfloat32 beta = (alpha - alpha0) / (1.0f - alpha0);\n\tc0 += beta * (c - c0);\n\ta0 += beta * (a - a0);\n\talpha0 = alpha;\n}\n\n/// Normalize an angle in radians to be between -pi and pi\ninline void b2Sweep::Normalize()\n{\n\tfloat32 twoPi = 2.0f * b2_pi;\n\tfloat32 d =  twoPi * floorf(a0 / twoPi);\n\ta0 -= d;\n\ta -= d;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_SHAPE_H\n#define B2_SHAPE_H\n\n#include <Box2D/Common/b2BlockAllocator.h>\n#include <Box2D/Common/b2Math.h>\n#include <Box2D/Collision/b2Collision.h>\n\n/// This holds the mass data computed for a shape.\nstruct b2MassData\n{\n\t/// The mass of the shape, usually in kilograms.\n\tfloat32 mass;\n\n\t/// The position of the shape's centroid relative to the shape's origin.\n\tb2Vec2 center;\n\n\t/// The rotational inertia of the shape about the local origin.\n\tfloat32 I;\n};\n\n/// A shape is used for collision detection. You can create a shape however you like.\n/// Shapes used for simulation in b2World are created automatically when a b2Fixture\n/// is created. Shapes may encapsulate a one or more child shapes.\nclass b2Shape\n{\npublic:\n\t\n\tenum Type\n\t{\n\t\te_circle = 0,\n\t\te_edge = 1,\n\t\te_polygon = 2,\n\t\te_chain = 3,\n\t\te_typeCount = 4\n\t};\n\n\tvirtual ~b2Shape() {}\n\n\t/// Clone the concrete shape using the provided allocator.\n\tvirtual b2Shape* Clone(b2BlockAllocator* allocator) const = 0;\n\n\t/// Get the type of this shape. You can use this to down cast to the concrete shape.\n\t/// @return the shape type.\n\tType GetType() const;\n\n\t/// Get the number of child primitives.\n\tvirtual int32 GetChildCount() const = 0;\n\n\t/// Test a point for containment in this shape. This only works for convex shapes.\n\t/// @param xf the shape world transform.\n\t/// @param p a point in world coordinates.\n\tvirtual bool TestPoint(const b2Transform& xf, const b2Vec2& p) const = 0;\n\n\t/// Cast a ray against a child shape.\n\t/// @param output the ray-cast results.\n\t/// @param input the ray-cast input parameters.\n\t/// @param transform the transform to be applied to the shape.\n\t/// @param childIndex the child shape index\n\tvirtual bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,\n\t\t\t\t\t\tconst b2Transform& transform, int32 childIndex) const = 0;\n\n\t/// Given a transform, compute the associated axis aligned bounding box for a child shape.\n\t/// @param aabb returns the axis aligned box.\n\t/// @param xf the world transform of the shape.\n\t/// @param childIndex the child shape\n\tvirtual void ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const = 0;\n\n\t/// Compute the mass properties of this shape using its dimensions and density.\n\t/// The inertia tensor is computed about the local origin.\n\t/// @param massData returns the mass data for this shape.\n\t/// @param density the density in kilograms per meter squared.\n\tvirtual void ComputeMass(b2MassData* massData, float32 density) const = 0;\n\n\tType m_type;\n\tfloat32 m_radius;\n};\n\ninline b2Shape::Type b2Shape::GetType() const\n{\n\treturn m_type;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_DISTANCE_JOINT_H\n#define B2_DISTANCE_JOINT_H\n\n#include <Box2D/Dynamics/Joints/b2Joint.h>\n\n/// Distance joint definition. This requires defining an\n/// anchor point on both bodies and the non-zero length of the\n/// distance joint. The definition uses local anchor points\n/// so that the initial configuration can violate the constraint\n/// slightly. This helps when saving and loading a game.\n/// @warning Do not use a zero or short length.\nstruct b2DistanceJointDef : public b2JointDef\n{\n\tb2DistanceJointDef()\n\t{\n\t\ttype = e_distanceJoint;\n\t\tlocalAnchorA.Set(0.0f, 0.0f);\n\t\tlocalAnchorB.Set(0.0f, 0.0f);\n\t\tlength = 1.0f;\n\t\tfrequencyHz = 0.0f;\n\t\tdampingRatio = 0.0f;\n\t}\n\n\t/// Initialize the bodies, anchors, and length using the world\n\t/// anchors.\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB,\n\t\t\t\t\tconst b2Vec2& anchorA, const b2Vec2& anchorB);\n\n\t/// The local anchor point relative to bodyA's origin.\n\tb2Vec2 localAnchorA;\n\n\t/// The local anchor point relative to bodyB's origin.\n\tb2Vec2 localAnchorB;\n\n\t/// The natural length between the anchor points.\n\tfloat32 length;\n\n\t/// The mass-spring-damper frequency in Hertz. A value of 0\n\t/// disables softness.\n\tfloat32 frequencyHz;\n\n\t/// The damping ratio. 0 = no damping, 1 = critical damping.\n\tfloat32 dampingRatio;\n};\n\n/// A distance joint constrains two points on two bodies\n/// to remain at a fixed distance from each other. You can view\n/// this as a massless, rigid rod.\nclass b2DistanceJoint : public b2Joint\n{\npublic:\n\n\tb2Vec2 GetAnchorA() const;\n\tb2Vec2 GetAnchorB() const;\n\n\t/// Get the reaction force given the inverse time step.\n\t/// Unit is N.\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\n\n\t/// Get the reaction torque given the inverse time step.\n\t/// Unit is N*m. This is always zero for a distance joint.\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\n\n\t/// The local anchor point relative to bodyA's origin.\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\n\n\t/// The local anchor point relative to bodyB's origin.\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\n\n\t/// Set/get the natural length.\n\t/// Manipulating the length can lead to non-physical behavior when the frequency is zero.\n\tvoid SetLength(float32 length);\n\tfloat32 GetLength() const;\n\n\t/// Set/get frequency in Hz.\n\tvoid SetFrequency(float32 hz);\n\tfloat32 GetFrequency() const;\n\n\t/// Set/get damping ratio.\n\tvoid SetDampingRatio(float32 ratio);\n\tfloat32 GetDampingRatio() const;\n\n\t/// Dump joint to dmLog\n\tvoid Dump();\n\nprotected:\n\n\tfriend class b2Joint;\n\tb2DistanceJoint(const b2DistanceJointDef* data);\n\n\tvoid InitVelocityConstraints(const b2SolverData& data);\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\n\tbool SolvePositionConstraints(const b2SolverData& data);\n\n\tfloat32 m_frequencyHz;\n\tfloat32 m_dampingRatio;\n\tfloat32 m_bias;\n\n\t// Solver shared\n\tb2Vec2 m_localAnchorA;\n\tb2Vec2 m_localAnchorB;\n\tfloat32 m_gamma;\n\tfloat32 m_impulse;\n\tfloat32 m_length;\n\n\t// Solver temp\n\tint32 m_indexA;\n\tint32 m_indexB;\n\tb2Vec2 m_u;\n\tb2Vec2 m_rA;\n\tb2Vec2 m_rB;\n\tb2Vec2 m_localCenterA;\n\tb2Vec2 m_localCenterB;\n\tfloat32 m_invMassA;\n\tfloat32 m_invMassB;\n\tfloat32 m_invIA;\n\tfloat32 m_invIB;\n\tfloat32 m_mass;\n};\n\ninline void b2DistanceJoint::SetLength(float32 length)\n{\n\tm_length = length;\n}\n\ninline float32 b2DistanceJoint::GetLength() const\n{\n\treturn m_length;\n}\n\ninline void b2DistanceJoint::SetFrequency(float32 hz)\n{\n\tm_frequencyHz = hz;\n}\n\ninline float32 b2DistanceJoint::GetFrequency() const\n{\n\treturn m_frequencyHz;\n}\n\ninline void b2DistanceJoint::SetDampingRatio(float32 ratio)\n{\n\tm_dampingRatio = ratio;\n}\n\ninline float32 b2DistanceJoint::GetDampingRatio() const\n{\n\treturn m_dampingRatio;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_FIXTURE_H\n#define B2_FIXTURE_H\n\n#include <Box2D/Dynamics/b2Body.h>\n#include <Box2D/Collision/b2Collision.h>\n#include <Box2D/Collision/Shapes/b2Shape.h>\n\nclass b2BlockAllocator;\nclass b2Body;\nclass b2BroadPhase;\nclass b2Fixture;\n\n/// This holds contact filtering data.\nstruct b2Filter\n{\n\tb2Filter()\n\t{\n\t\tcategoryBits = 0x0001;\n\t\tmaskBits = 0xFFFF;\n\t\tgroupIndex = 0;\n\t}\n\n\t/// The collision category bits. Normally you would just set one bit.\n\tuint16 categoryBits;\n\n\t/// The collision mask bits. This states the categories that this\n\t/// shape would accept for collision.\n\tuint16 maskBits;\n\n\t/// Collision groups allow a certain group of objects to never collide (negative)\n\t/// or always collide (positive). Zero means no collision group. Non-zero group\n\t/// filtering always wins against the mask bits.\n\tint16 groupIndex;\n};\n\n/// A fixture definition is used to create a fixture. This class defines an\n/// abstract fixture definition. You can reuse fixture definitions safely.\nstruct b2FixtureDef\n{\n\t/// The constructor sets the default fixture definition values.\n\tb2FixtureDef()\n\t{\n\t\tshape = NULL;\n\t\tuserData = NULL;\n\t\tfriction = 0.2f;\n\t\trestitution = 0.0f;\n\t\tdensity = 0.0f;\n\t\tisSensor = false;\n\t}\n\n\t/// The shape, this must be set. The shape will be cloned, so you\n\t/// can create the shape on the stack.\n\tconst b2Shape* shape;\n\n\t/// Use this to store application specific fixture data.\n\tvoid* userData;\n\n\t/// The friction coefficient, usually in the range [0,1].\n\tfloat32 friction;\n\n\t/// The restitution (elasticity) usually in the range [0,1].\n\tfloat32 restitution;\n\n\t/// The density, usually in kg/m^2.\n\tfloat32 density;\n\n\t/// A sensor shape collects contact information but never generates a collision\n\t/// response.\n\tbool isSensor;\n\n\t/// Contact filtering data.\n\tb2Filter filter;\n};\n\n/// This proxy is used internally to connect fixtures to the broad-phase.\nstruct b2FixtureProxy\n{\n\tb2AABB aabb;\n\tb2Fixture* fixture;\n\tint32 childIndex;\n\tint32 proxyId;\n};\n\n/// A fixture is used to attach a shape to a body for collision detection. A fixture\n/// inherits its transform from its parent. Fixtures hold additional non-geometric data\n/// such as friction, collision filters, etc.\n/// Fixtures are created via b2Body::CreateFixture.\n/// @warning you cannot reuse fixtures.\nclass b2Fixture\n{\npublic:\n\t/// Get the type of the child shape. You can use this to down cast to the concrete shape.\n\t/// @return the shape type.\n\tb2Shape::Type GetType() const;\n\n\t/// Get the child shape. You can modify the child shape, however you should not change the\n\t/// number of vertices because this will crash some collision caching mechanisms.\n\t/// Manipulating the shape may lead to non-physical behavior.\n\tb2Shape* GetShape();\n\tconst b2Shape* GetShape() const;\n\n\t/// Set if this fixture is a sensor.\n\tvoid SetSensor(bool sensor);\n\n\t/// Is this fixture a sensor (non-solid)?\n\t/// @return the true if the shape is a sensor.\n\tbool IsSensor() const;\n\n\t/// Set the contact filtering data. This will not update contacts until the next time\n\t/// step when either parent body is active and awake.\n\t/// This automatically calls Refilter.\n\tvoid SetFilterData(const b2Filter& filter);\n\n\t/// Get the contact filtering data.\n\tconst b2Filter& GetFilterData() const;\n\n\t/// Call this if you want to establish collision that was previously disabled by b2ContactFilter::ShouldCollide.\n\tvoid Refilter();\n\n\t/// Get the parent body of this fixture. This is NULL if the fixture is not attached.\n\t/// @return the parent body.\n\tb2Body* GetBody();\n\tconst b2Body* GetBody() const;\n\n\t/// Get the next fixture in the parent body's fixture list.\n\t/// @return the next shape.\n\tb2Fixture* GetNext();\n\tconst b2Fixture* GetNext() const;\n\n\t/// Get the user data that was assigned in the fixture definition. Use this to\n\t/// store your application specific data.\n\tvoid* GetUserData() const;\n\n\t/// Set the user data. Use this to store your application specific data.\n\tvoid SetUserData(void* data);\n\n\t/// Test a point for containment in this fixture.\n\t/// @param p a point in world coordinates.\n\tbool TestPoint(const b2Vec2& p) const;\n\n\t/// Cast a ray against this shape.\n\t/// @param output the ray-cast results.\n\t/// @param input the ray-cast input parameters.\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input, int32 childIndex) const;\n\n\t/// Get the mass data for this fixture. The mass data is based on the density and\n\t/// the shape. The rotational inertia is about the shape's origin. This operation\n\t/// may be expensive.\n\tvoid GetMassData(b2MassData* massData) const;\n\n\t/// Set the density of this fixture. This will _not_ automatically adjust the mass\n\t/// of the body. You must call b2Body::ResetMassData to update the body's mass.\n\tvoid SetDensity(float32 density);\n\n\t/// Get the density of this fixture.\n\tfloat32 GetDensity() const;\n\n\t/// Get the coefficient of friction.\n\tfloat32 GetFriction() const;\n\n\t/// Set the coefficient of friction. This will _not_ change the friction of\n\t/// existing contacts.\n\tvoid SetFriction(float32 friction);\n\n\t/// Get the coefficient of restitution.\n\tfloat32 GetRestitution() const;\n\n\t/// Set the coefficient of restitution. This will _not_ change the restitution of\n\t/// existing contacts.\n\tvoid SetRestitution(float32 restitution);\n\n\t/// Get the fixture's AABB. This AABB may be enlarge and/or stale.\n\t/// If you need a more accurate AABB, compute it using the shape and\n\t/// the body transform.\n\tconst b2AABB& GetAABB(int32 childIndex) const;\n\n\t/// Dump this fixture to the log file.\n\tvoid Dump(int32 bodyIndex);\n\nprotected:\n\n\tfriend class b2Body;\n\tfriend class b2World;\n\tfriend class b2Contact;\n\tfriend class b2ContactManager;\n\n\tb2Fixture();\n\n\t// We need separation create/destroy functions from the constructor/destructor because\n\t// the destructor cannot access the allocator (no destructor arguments allowed by C++).\n\tvoid Create(b2BlockAllocator* allocator, b2Body* body, const b2FixtureDef* def);\n\tvoid Destroy(b2BlockAllocator* allocator);\n\n\t// These support body activation/deactivation.\n\tvoid CreateProxies(b2BroadPhase* broadPhase, const b2Transform& xf);\n\tvoid DestroyProxies(b2BroadPhase* broadPhase);\n\n\tvoid Synchronize(b2BroadPhase* broadPhase, const b2Transform& xf1, const b2Transform& xf2);\n\n\tfloat32 m_density;\n\n\tb2Fixture* m_next;\n\tb2Body* m_body;\n\n\tb2Shape* m_shape;\n\n\tfloat32 m_friction;\n\tfloat32 m_restitution;\n\n\tb2FixtureProxy* m_proxies;\n\tint32 m_proxyCount;\n\n\tb2Filter m_filter;\n\n\tbool m_isSensor;\n\n\tvoid* m_userData;\n};\n\ninline b2Shape::Type b2Fixture::GetType() const\n{\n\treturn m_shape->GetType();\n}\n\ninline b2Shape* b2Fixture::GetShape()\n{\n\treturn m_shape;\n}\n\ninline const b2Shape* b2Fixture::GetShape() const\n{\n\treturn m_shape;\n}\n\ninline bool b2Fixture::IsSensor() const\n{\n\treturn m_isSensor;\n}\n\ninline const b2Filter& b2Fixture::GetFilterData() const\n{\n\treturn m_filter;\n}\n\ninline void* b2Fixture::GetUserData() const\n{\n\treturn m_userData;\n}\n\ninline void b2Fixture::SetUserData(void* data)\n{\n\tm_userData = data;\n}\n\ninline b2Body* b2Fixture::GetBody()\n{\n\treturn m_body;\n}\n\ninline const b2Body* b2Fixture::GetBody() const\n{\n\treturn m_body;\n}\n\ninline b2Fixture* b2Fixture::GetNext()\n{\n\treturn m_next;\n}\n\ninline const b2Fixture* b2Fixture::GetNext() const\n{\n\treturn m_next;\n}\n\ninline void b2Fixture::SetDensity(float32 density)\n{\n\tb2Assert(b2IsValid(density) && density >= 0.0f);\n\tm_density = density;\n}\n\ninline float32 b2Fixture::GetDensity() const\n{\n\treturn m_density;\n}\n\ninline float32 b2Fixture::GetFriction() const\n{\n\treturn m_friction;\n}\n\ninline void b2Fixture::SetFriction(float32 friction)\n{\n\tm_friction = friction;\n}\n\ninline float32 b2Fixture::GetRestitution() const\n{\n\treturn m_restitution;\n}\n\ninline void b2Fixture::SetRestitution(float32 restitution)\n{\n\tm_restitution = restitution;\n}\n\ninline bool b2Fixture::TestPoint(const b2Vec2& p) const\n{\n\treturn m_shape->TestPoint(m_body->GetTransform(), p);\n}\n\ninline bool b2Fixture::RayCast(b2RayCastOutput* output, const b2RayCastInput& input, int32 childIndex) const\n{\n\treturn m_shape->RayCast(output, input, m_body->GetTransform(), childIndex);\n}\n\ninline void b2Fixture::GetMassData(b2MassData* massData) const\n{\n\tm_shape->ComputeMass(massData, m_density);\n}\n\ninline const b2AABB& b2Fixture::GetAABB(int32 childIndex) const\n{\n\tb2Assert(0 <= childIndex && childIndex < m_proxyCount);\n\treturn m_proxies[childIndex].aabb;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_BODY_H\n#define B2_BODY_H\n\n#include <Box2D/Common/b2Math.h>\n#include <Box2D/Collision/Shapes/b2Shape.h>\n#include <memory>\n\nclass b2Fixture;\nclass b2Joint;\nclass b2Contact;\nclass b2Controller;\nclass b2World;\nstruct b2FixtureDef;\nstruct b2JointEdge;\nstruct b2ContactEdge;\n\n/// The body type.\n/// static: zero mass, zero velocity, may be manually moved\n/// kinematic: zero mass, non-zero velocity set by user, moved by solver\n/// dynamic: positive mass, non-zero velocity determined by forces, moved by solver\nenum b2BodyType\n{\n\tb2_staticBody = 0,\n\tb2_kinematicBody,\n\tb2_dynamicBody\n\n\t// TODO_ERIN\n\t//b2_bulletBody,\n};\n\n/// A body definition holds all the data needed to construct a rigid body.\n/// You can safely re-use body definitions. Shapes are added to a body after construction.\nstruct b2BodyDef\n{\n\t/// This constructor sets the body definition default values.\n\tb2BodyDef()\n\t{\n\t\tuserData = NULL;\n\t\tposition.Set(0.0f, 0.0f);\n\t\tangle = 0.0f;\n\t\tlinearVelocity.Set(0.0f, 0.0f);\n\t\tangularVelocity = 0.0f;\n\t\tlinearDamping = 0.0f;\n\t\tangularDamping = 0.0f;\n\t\tallowSleep = true;\n\t\tawake = true;\n\t\tfixedRotation = false;\n\t\tbullet = false;\n\t\ttype = b2_staticBody;\n\t\tactive = true;\n\t\tgravityScale = 1.0f;\n\t}\n\n\t/// The body type: static, kinematic, or dynamic.\n\t/// Note: if a dynamic body would have zero mass, the mass is set to one.\n\tb2BodyType type;\n\n\t/// The world position of the body. Avoid creating bodies at the origin\n\t/// since this can lead to many overlapping shapes.\n\tb2Vec2 position;\n\n\t/// The world angle of the body in radians.\n\tfloat32 angle;\n\n\t/// The linear velocity of the body's origin in world co-ordinates.\n\tb2Vec2 linearVelocity;\n\n\t/// The angular velocity of the body.\n\tfloat32 angularVelocity;\n\n\t/// Linear damping is use to reduce the linear velocity. The damping parameter\n\t/// can be larger than 1.0f but the damping effect becomes sensitive to the\n\t/// time step when the damping parameter is large.\n\tfloat32 linearDamping;\n\n\t/// Angular damping is use to reduce the angular velocity. The damping parameter\n\t/// can be larger than 1.0f but the damping effect becomes sensitive to the\n\t/// time step when the damping parameter is large.\n\tfloat32 angularDamping;\n\n\t/// Set this flag to false if this body should never fall asleep. Note that\n\t/// this increases CPU usage.\n\tbool allowSleep;\n\n\t/// Is this body initially awake or sleeping?\n\tbool awake;\n\n\t/// Should this body be prevented from rotating? Useful for characters.\n\tbool fixedRotation;\n\n\t/// Is this a fast moving body that should be prevented from tunneling through\n\t/// other moving bodies? Note that all bodies are prevented from tunneling through\n\t/// kinematic and static bodies. This setting is only considered on dynamic bodies.\n\t/// @warning You should use this flag sparingly since it increases processing time.\n\tbool bullet;\n\n\t/// Does this body start out active?\n\tbool active;\n\n\t/// Use this to store application specific body data.\n\tvoid* userData;\n\n\t/// Scale the gravity applied to this body.\n\tfloat32 gravityScale;\n};\n\n/// A rigid body. These are created via b2World::CreateBody.\nclass b2Body\n{\npublic:\n\t/// Creates a fixture and attach it to this body. Use this function if you need\n\t/// to set some fixture parameters, like friction. Otherwise you can create the\n\t/// fixture directly from a shape.\n\t/// If the density is non-zero, this function automatically updates the mass of the body.\n\t/// Contacts are not created until the next time step.\n\t/// @param def the fixture definition.\n\t/// @warning This function is locked during callbacks.\n\tb2Fixture* CreateFixture(const b2FixtureDef* def);\n\n\t/// Creates a fixture from a shape and attach it to this body.\n\t/// This is a convenience function. Use b2FixtureDef if you need to set parameters\n\t/// like friction, restitution, user data, or filtering.\n\t/// If the density is non-zero, this function automatically updates the mass of the body.\n\t/// @param shape the shape to be cloned.\n\t/// @param density the shape density (set to zero for static bodies).\n\t/// @warning This function is locked during callbacks.\n\tb2Fixture* CreateFixture(const b2Shape* shape, float32 density);\n\n\t/// Destroy a fixture. This removes the fixture from the broad-phase and\n\t/// destroys all contacts associated with this fixture. This will\n\t/// automatically adjust the mass of the body if the body is dynamic and the\n\t/// fixture has positive density.\n\t/// All fixtures attached to a body are implicitly destroyed when the body is destroyed.\n\t/// @param fixture the fixture to be removed.\n\t/// @warning This function is locked during callbacks.\n\tvoid DestroyFixture(b2Fixture* fixture);\n\n\t/// Set the position of the body's origin and rotation.\n\t/// Manipulating a body's transform may cause non-physical behavior.\n\t/// Note: contacts are updated on the next call to b2World::Step.\n\t/// @param position the world position of the body's local origin.\n\t/// @param angle the world rotation in radians.\n\tvoid SetTransform(const b2Vec2& position, float32 angle);\n\n\t/// Get the body transform for the body's origin.\n\t/// @return the world transform of the body's origin.\n\tconst b2Transform& GetTransform() const;\n\n\t/// Get the world body origin position.\n\t/// @return the world position of the body's origin.\n\tconst b2Vec2& GetPosition() const;\n\n\t/// Get the angle in radians.\n\t/// @return the current world rotation angle in radians.\n\tfloat32 GetAngle() const;\n\n\t/// Get the world position of the center of mass.\n\tconst b2Vec2& GetWorldCenter() const;\n\n\t/// Get the local position of the center of mass.\n\tconst b2Vec2& GetLocalCenter() const;\n\n\t/// Set the linear velocity of the center of mass.\n\t/// @param v the new linear velocity of the center of mass.\n\tvoid SetLinearVelocity(const b2Vec2& v);\n\n\t/// Get the linear velocity of the center of mass.\n\t/// @return the linear velocity of the center of mass.\n\tconst b2Vec2& GetLinearVelocity() const;\n\n\t/// Set the angular velocity.\n\t/// @param omega the new angular velocity in radians/second.\n\tvoid SetAngularVelocity(float32 omega);\n\n\t/// Get the angular velocity.\n\t/// @return the angular velocity in radians/second.\n\tfloat32 GetAngularVelocity() const;\n\n\t/// Apply a force at a world point. If the force is not\n\t/// applied at the center of mass, it will generate a torque and\n\t/// affect the angular velocity. This wakes up the body.\n\t/// @param force the world force vector, usually in Newtons (N).\n\t/// @param point the world position of the point of application.\n\t/// @param wake also wake up the body\n\tvoid ApplyForce(const b2Vec2& force, const b2Vec2& point, bool wake);\n\n\t/// Apply a force to the center of mass. This wakes up the body.\n\t/// @param force the world force vector, usually in Newtons (N).\n\t/// @param wake also wake up the body\n\tvoid ApplyForceToCenter(const b2Vec2& force, bool wake);\n\n\t/// Apply a torque. This affects the angular velocity\n\t/// without affecting the linear velocity of the center of mass.\n\t/// This wakes up the body.\n\t/// @param torque about the z-axis (out of the screen), usually in N-m.\n\t/// @param wake also wake up the body\n\tvoid ApplyTorque(float32 torque, bool wake);\n\n\t/// Apply an impulse at a point. This immediately modifies the velocity.\n\t/// It also modifies the angular velocity if the point of application\n\t/// is not at the center of mass. This wakes up the body.\n\t/// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.\n\t/// @param point the world position of the point of application.\n\t/// @param wake also wake up the body\n\tvoid ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point, bool wake);\n\n\t/// Apply an angular impulse.\n\t/// @param impulse the angular impulse in units of kg*m*m/s\n\t/// @param wake also wake up the body\n\tvoid ApplyAngularImpulse(float32 impulse, bool wake);\n\n\t/// Get the total mass of the body.\n\t/// @return the mass, usually in kilograms (kg).\n\tfloat32 GetMass() const;\n\n\t/// Get the rotational inertia of the body about the local origin.\n\t/// @return the rotational inertia, usually in kg-m^2.\n\tfloat32 GetInertia() const;\n\n\t/// Get the mass data of the body.\n\t/// @return a struct containing the mass, inertia and center of the body.\n\tvoid GetMassData(b2MassData* data) const;\n\n\t/// Set the mass properties to override the mass properties of the fixtures.\n\t/// Note that this changes the center of mass position.\n\t/// Note that creating or destroying fixtures can also alter the mass.\n\t/// This function has no effect if the body isn't dynamic.\n\t/// @param massData the mass properties.\n\tvoid SetMassData(const b2MassData* data);\n\n\t/// This resets the mass properties to the sum of the mass properties of the fixtures.\n\t/// This normally does not need to be called unless you called SetMassData to override\n\t/// the mass and you later want to reset the mass.\n\tvoid ResetMassData();\n\n\t/// Get the world coordinates of a point given the local coordinates.\n\t/// @param localPoint a point on the body measured relative the the body's origin.\n\t/// @return the same point expressed in world coordinates.\n\tb2Vec2 GetWorldPoint(const b2Vec2& localPoint) const;\n\n\t/// Get the world coordinates of a vector given the local coordinates.\n\t/// @param localVector a vector fixed in the body.\n\t/// @return the same vector expressed in world coordinates.\n\tb2Vec2 GetWorldVector(const b2Vec2& localVector) const;\n\n\t/// Gets a local point relative to the body's origin given a world point.\n\t/// @param a point in world coordinates.\n\t/// @return the corresponding local point relative to the body's origin.\n\tb2Vec2 GetLocalPoint(const b2Vec2& worldPoint) const;\n\n\t/// Gets a local vector given a world vector.\n\t/// @param a vector in world coordinates.\n\t/// @return the corresponding local vector.\n\tb2Vec2 GetLocalVector(const b2Vec2& worldVector) const;\n\n\t/// Get the world linear velocity of a world point attached to this body.\n\t/// @param a point in world coordinates.\n\t/// @return the world velocity of a point.\n\tb2Vec2 GetLinearVelocityFromWorldPoint(const b2Vec2& worldPoint) const;\n\n\t/// Get the world velocity of a local point.\n\t/// @param a point in local coordinates.\n\t/// @return the world velocity of a point.\n\tb2Vec2 GetLinearVelocityFromLocalPoint(const b2Vec2& localPoint) const;\n\n\t/// Get the linear damping of the body.\n\tfloat32 GetLinearDamping() const;\n\n\t/// Set the linear damping of the body.\n\tvoid SetLinearDamping(float32 linearDamping);\n\n\t/// Get the angular damping of the body.\n\tfloat32 GetAngularDamping() const;\n\n\t/// Set the angular damping of the body.\n\tvoid SetAngularDamping(float32 angularDamping);\n\n\t/// Get the gravity scale of the body.\n\tfloat32 GetGravityScale() const;\n\n\t/// Set the gravity scale of the body.\n\tvoid SetGravityScale(float32 scale);\n\n\t/// Set the type of this body. This may alter the mass and velocity.\n\tvoid SetType(b2BodyType type);\n\n\t/// Get the type of this body.\n\tb2BodyType GetType() const;\n\n\t/// Should this body be treated like a bullet for continuous collision detection?\n\tvoid SetBullet(bool flag);\n\n\t/// Is this body treated like a bullet for continuous collision detection?\n\tbool IsBullet() const;\n\n\t/// You can disable sleeping on this body. If you disable sleeping, the\n\t/// body will be woken.\n\tvoid SetSleepingAllowed(bool flag);\n\n\t/// Is this body allowed to sleep\n\tbool IsSleepingAllowed() const;\n\n\t/// Set the sleep state of the body. A sleeping body has very\n\t/// low CPU cost.\n\t/// @param flag set to true to wake the body, false to put it to sleep.\n\tvoid SetAwake(bool flag);\n\n\t/// Get the sleeping state of this body.\n\t/// @return true if the body is awake.\n\tbool IsAwake() const;\n\n\t/// Set the active state of the body. An inactive body is not\n\t/// simulated and cannot be collided with or woken up.\n\t/// If you pass a flag of true, all fixtures will be added to the\n\t/// broad-phase.\n\t/// If you pass a flag of false, all fixtures will be removed from\n\t/// the broad-phase and all contacts will be destroyed.\n\t/// Fixtures and joints are otherwise unaffected. You may continue\n\t/// to create/destroy fixtures and joints on inactive bodies.\n\t/// Fixtures on an inactive body are implicitly inactive and will\n\t/// not participate in collisions, ray-casts, or queries.\n\t/// Joints connected to an inactive body are implicitly inactive.\n\t/// An inactive body is still owned by a b2World object and remains\n\t/// in the body list.\n\tvoid SetActive(bool flag);\n\n\t/// Get the active state of the body.\n\tbool IsActive() const;\n\n\t/// Set this body to have fixed rotation. This causes the mass\n\t/// to be reset.\n\tvoid SetFixedRotation(bool flag);\n\n\t/// Does this body have fixed rotation?\n\tbool IsFixedRotation() const;\n\n\t/// Get the list of all fixtures attached to this body.\n\tb2Fixture* GetFixtureList();\n\tconst b2Fixture* GetFixtureList() const;\n\n\t/// Get the list of all joints attached to this body.\n\tb2JointEdge* GetJointList();\n\tconst b2JointEdge* GetJointList() const;\n\n\t/// Get the list of all contacts attached to this body.\n\t/// @warning this list changes during the time step and you may\n\t/// miss some collisions if you don't use b2ContactListener.\n\tb2ContactEdge* GetContactList();\n\tconst b2ContactEdge* GetContactList() const;\n\n\t/// Get the next body in the world's body list.\n\tb2Body* GetNext();\n\tconst b2Body* GetNext() const;\n\n\t/// Get the user data pointer that was provided in the body definition.\n\tvoid* GetUserData() const;\n\n\t/// Set the user data. Use this to store your application specific data.\n\tvoid SetUserData(void* data);\n\n\t/// Get the parent world of this body.\n\tb2World* GetWorld();\n\tconst b2World* GetWorld() const;\n\n\t/// Dump this body to a log file\n\tvoid Dump();\n\nprivate:\n\n\tfriend class b2World;\n\tfriend class b2Island;\n\tfriend class b2ContactManager;\n\tfriend class b2ContactSolver;\n\tfriend class b2Contact;\n\t\n\tfriend class b2DistanceJoint;\n\tfriend class b2FrictionJoint;\n\tfriend class b2GearJoint;\n\tfriend class b2MotorJoint;\n\tfriend class b2MouseJoint;\n\tfriend class b2PrismaticJoint;\n\tfriend class b2PulleyJoint;\n\tfriend class b2RevoluteJoint;\n\tfriend class b2RopeJoint;\n\tfriend class b2WeldJoint;\n\tfriend class b2WheelJoint;\n\n\t// m_flags\n\tenum\n\t{\n\t\te_islandFlag\t\t= 0x0001,\n\t\te_awakeFlag\t\t\t= 0x0002,\n\t\te_autoSleepFlag\t\t= 0x0004,\n\t\te_bulletFlag\t\t= 0x0008,\n\t\te_fixedRotationFlag\t= 0x0010,\n\t\te_activeFlag\t\t= 0x0020,\n\t\te_toiFlag\t\t\t= 0x0040\n\t};\n\n\tb2Body(const b2BodyDef* bd, b2World* world);\n\t~b2Body();\n\n\tvoid SynchronizeFixtures();\n\tvoid SynchronizeTransform();\n\n\t// This is used to prevent connected bodies from colliding.\n\t// It may lie, depending on the collideConnected flag.\n\tbool ShouldCollide(const b2Body* other) const;\n\n\tvoid Advance(float32 t);\n\n\tb2BodyType m_type;\n\n\tuint16 m_flags;\n\n\tint32 m_islandIndex;\n\n\tb2Transform m_xf;\t\t// the body origin transform\n\tb2Sweep m_sweep;\t\t// the swept motion for CCD\n\n\tb2Vec2 m_linearVelocity;\n\tfloat32 m_angularVelocity;\n\n\tb2Vec2 m_force;\n\tfloat32 m_torque;\n\n\tb2World* m_world;\n\tb2Body* m_prev;\n\tb2Body* m_next;\n\n\tb2Fixture* m_fixtureList;\n\tint32 m_fixtureCount;\n\n\tb2JointEdge* m_jointList;\n\tb2ContactEdge* m_contactList;\n\n\tfloat32 m_mass, m_invMass;\n\n\t// Rotational inertia about the center of mass.\n\tfloat32 m_I, m_invI;\n\n\tfloat32 m_linearDamping;\n\tfloat32 m_angularDamping;\n\tfloat32 m_gravityScale;\n\n\tfloat32 m_sleepTime;\n\n\tvoid* m_userData;\n};\n\ninline b2BodyType b2Body::GetType() const\n{\n\treturn m_type;\n}\n\ninline const b2Transform& b2Body::GetTransform() const\n{\n\treturn m_xf;\n}\n\ninline const b2Vec2& b2Body::GetPosition() const\n{\n\treturn m_xf.p;\n}\n\ninline float32 b2Body::GetAngle() const\n{\n\treturn m_sweep.a;\n}\n\ninline const b2Vec2& b2Body::GetWorldCenter() const\n{\n\treturn m_sweep.c;\n}\n\ninline const b2Vec2& b2Body::GetLocalCenter() const\n{\n\treturn m_sweep.localCenter;\n}\n\ninline void b2Body::SetLinearVelocity(const b2Vec2& v)\n{\n\tif (m_type == b2_staticBody)\n\t{\n\t\treturn;\n\t}\n\n\tif (b2Dot(v,v) > 0.0f)\n\t{\n\t\tSetAwake(true);\n\t}\n\n\tm_linearVelocity = v;\n}\n\ninline const b2Vec2& b2Body::GetLinearVelocity() const\n{\n\treturn m_linearVelocity;\n}\n\ninline void b2Body::SetAngularVelocity(float32 w)\n{\n\tif (m_type == b2_staticBody)\n\t{\n\t\treturn;\n\t}\n\n\tif (w * w > 0.0f)\n\t{\n\t\tSetAwake(true);\n\t}\n\n\tm_angularVelocity = w;\n}\n\ninline float32 b2Body::GetAngularVelocity() const\n{\n\treturn m_angularVelocity;\n}\n\ninline float32 b2Body::GetMass() const\n{\n\treturn m_mass;\n}\n\ninline float32 b2Body::GetInertia() const\n{\n\treturn m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);\n}\n\ninline void b2Body::GetMassData(b2MassData* data) const\n{\n\tdata->mass = m_mass;\n\tdata->I = m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);\n\tdata->center = m_sweep.localCenter;\n}\n\ninline b2Vec2 b2Body::GetWorldPoint(const b2Vec2& localPoint) const\n{\n\treturn b2Mul(m_xf, localPoint);\n}\n\ninline b2Vec2 b2Body::GetWorldVector(const b2Vec2& localVector) const\n{\n\treturn b2Mul(m_xf.q, localVector);\n}\n\ninline b2Vec2 b2Body::GetLocalPoint(const b2Vec2& worldPoint) const\n{\n\treturn b2MulT(m_xf, worldPoint);\n}\n\ninline b2Vec2 b2Body::GetLocalVector(const b2Vec2& worldVector) const\n{\n\treturn b2MulT(m_xf.q, worldVector);\n}\n\ninline b2Vec2 b2Body::GetLinearVelocityFromWorldPoint(const b2Vec2& worldPoint) const\n{\n\treturn m_linearVelocity + b2Cross(m_angularVelocity, worldPoint - m_sweep.c);\n}\n\ninline b2Vec2 b2Body::GetLinearVelocityFromLocalPoint(const b2Vec2& localPoint) const\n{\n\treturn GetLinearVelocityFromWorldPoint(GetWorldPoint(localPoint));\n}\n\ninline float32 b2Body::GetLinearDamping() const\n{\n\treturn m_linearDamping;\n}\n\ninline void b2Body::SetLinearDamping(float32 linearDamping)\n{\n\tm_linearDamping = linearDamping;\n}\n\ninline float32 b2Body::GetAngularDamping() const\n{\n\treturn m_angularDamping;\n}\n\ninline void b2Body::SetAngularDamping(float32 angularDamping)\n{\n\tm_angularDamping = angularDamping;\n}\n\ninline float32 b2Body::GetGravityScale() const\n{\n\treturn m_gravityScale;\n}\n\ninline void b2Body::SetGravityScale(float32 scale)\n{\n\tm_gravityScale = scale;\n}\n\ninline void b2Body::SetBullet(bool flag)\n{\n\tif (flag)\n\t{\n\t\tm_flags |= e_bulletFlag;\n\t}\n\telse\n\t{\n\t\tm_flags &= ~e_bulletFlag;\n\t}\n}\n\ninline bool b2Body::IsBullet() const\n{\n\treturn (m_flags & e_bulletFlag) == e_bulletFlag;\n}\n\ninline void b2Body::SetAwake(bool flag)\n{\n\tif (flag)\n\t{\n\t\tif ((m_flags & e_awakeFlag) == 0)\n\t\t{\n\t\t\tm_flags |= e_awakeFlag;\n\t\t\tm_sleepTime = 0.0f;\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_flags &= ~e_awakeFlag;\n\t\tm_sleepTime = 0.0f;\n\t\tm_linearVelocity.SetZero();\n\t\tm_angularVelocity = 0.0f;\n\t\tm_force.SetZero();\n\t\tm_torque = 0.0f;\n\t}\n}\n\ninline bool b2Body::IsAwake() const\n{\n\treturn (m_flags & e_awakeFlag) == e_awakeFlag;\n}\n\ninline bool b2Body::IsActive() const\n{\n\treturn (m_flags & e_activeFlag) == e_activeFlag;\n}\n\ninline bool b2Body::IsFixedRotation() const\n{\n\treturn (m_flags & e_fixedRotationFlag) == e_fixedRotationFlag;\n}\n\ninline void b2Body::SetSleepingAllowed(bool flag)\n{\n\tif (flag)\n\t{\n\t\tm_flags |= e_autoSleepFlag;\n\t}\n\telse\n\t{\n\t\tm_flags &= ~e_autoSleepFlag;\n\t\tSetAwake(true);\n\t}\n}\n\ninline bool b2Body::IsSleepingAllowed() const\n{\n\treturn (m_flags & e_autoSleepFlag) == e_autoSleepFlag;\n}\n\ninline b2Fixture* b2Body::GetFixtureList()\n{\n\treturn m_fixtureList;\n}\n\ninline const b2Fixture* b2Body::GetFixtureList() const\n{\n\treturn m_fixtureList;\n}\n\ninline b2JointEdge* b2Body::GetJointList()\n{\n\treturn m_jointList;\n}\n\ninline const b2JointEdge* b2Body::GetJointList() const\n{\n\treturn m_jointList;\n}\n\ninline b2ContactEdge* b2Body::GetContactList()\n{\n\treturn m_contactList;\n}\n\ninline const b2ContactEdge* b2Body::GetContactList() const\n{\n\treturn m_contactList;\n}\n\ninline b2Body* b2Body::GetNext()\n{\n\treturn m_next;\n}\n\ninline const b2Body* b2Body::GetNext() const\n{\n\treturn m_next;\n}\n\ninline void b2Body::SetUserData(void* data)\n{\n\tm_userData = data;\n}\n\ninline void* b2Body::GetUserData() const\n{\n\treturn m_userData;\n}\n\ninline void b2Body::ApplyForce(const b2Vec2& force, const b2Vec2& point, bool wake)\n{\n\tif (m_type != b2_dynamicBody)\n\t{\n\t\treturn;\n\t}\n\n\tif (wake && (m_flags & e_awakeFlag) == 0)\n\t{\n\t\tSetAwake(true);\n\t}\n\n\t// Don't accumulate a force if the body is sleeping.\n\tif (m_flags & e_awakeFlag)\n\t{\n\t\tm_force += force;\n\t\tm_torque += b2Cross(point - m_sweep.c, force);\n\t}\n}\n\ninline void b2Body::ApplyForceToCenter(const b2Vec2& force, bool wake)\n{\n\tif (m_type != b2_dynamicBody)\n\t{\n\t\treturn;\n\t}\n\n\tif (wake && (m_flags & e_awakeFlag) == 0)\n\t{\n\t\tSetAwake(true);\n\t}\n\n\t// Don't accumulate a force if the body is sleeping\n\tif (m_flags & e_awakeFlag)\n\t{\n\t\tm_force += force;\n\t}\n}\n\ninline void b2Body::ApplyTorque(float32 torque, bool wake)\n{\n\tif (m_type != b2_dynamicBody)\n\t{\n\t\treturn;\n\t}\n\n\tif (wake && (m_flags & e_awakeFlag) == 0)\n\t{\n\t\tSetAwake(true);\n\t}\n\n\t// Don't accumulate a force if the body is sleeping\n\tif (m_flags & e_awakeFlag)\n\t{\n\t\tm_torque += torque;\n\t}\n}\n\ninline void b2Body::ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point, bool wake)\n{\n\tif (m_type != b2_dynamicBody)\n\t{\n\t\treturn;\n\t}\n\n\tif (wake && (m_flags & e_awakeFlag) == 0)\n\t{\n\t\tSetAwake(true);\n\t}\n\n\t// Don't accumulate velocity if the body is sleeping\n\tif (m_flags & e_awakeFlag)\n\t{\n\t\tm_linearVelocity += m_invMass * impulse;\n\t\tm_angularVelocity += m_invI * b2Cross(point - m_sweep.c, impulse);\n\t}\n}\n\ninline void b2Body::ApplyAngularImpulse(float32 impulse, bool wake)\n{\n\tif (m_type != b2_dynamicBody)\n\t{\n\t\treturn;\n\t}\n\n\tif (wake && (m_flags & e_awakeFlag) == 0)\n\t{\n\t\tSetAwake(true);\n\t}\n\n\t// Don't accumulate velocity if the body is sleeping\n\tif (m_flags & e_awakeFlag)\n\t{\n\t\tm_angularVelocity += m_invI * impulse;\n\t}\n}\n\ninline void b2Body::SynchronizeTransform()\n{\n\tm_xf.q.Set(m_sweep.a);\n\tm_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);\n}\n\ninline void b2Body::Advance(float32 alpha)\n{\n\t// Advance to the new safe time. This doesn't sync the broad-phase.\n\tm_sweep.Advance(alpha);\n\tm_sweep.c = m_sweep.c0;\n\tm_sweep.a = m_sweep.a0;\n\tm_xf.q.Set(m_sweep.a);\n\tm_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);\n}\n\ninline b2World* b2Body::GetWorld()\n{\n\treturn m_world;\n}\n\ninline const b2World* b2Body::GetWorld() const\n{\n\treturn m_world;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_COLLISION_H\n#define B2_COLLISION_H\n\n#include <Box2D/Common/b2Math.h>\n#include <limits.h>\n\n/// @file\n/// Structures and functions used for computing contact points, distance\n/// queries, and TOI queries.\n\nclass b2Shape;\nclass b2CircleShape;\nclass b2EdgeShape;\nclass b2PolygonShape;\n\nconst uint8 b2_nullFeature = UCHAR_MAX;\n\n/// The features that intersect to form the contact point\n/// This must be 4 bytes or less.\nstruct b2ContactFeature\n{\n\tenum Type\n\t{\n\t\te_vertex = 0,\n\t\te_face = 1\n\t};\n\n\tuint8 indexA;\t\t///< Feature index on shapeA\n\tuint8 indexB;\t\t///< Feature index on shapeB\n\tuint8 typeA;\t\t///< The feature type on shapeA\n\tuint8 typeB;\t\t///< The feature type on shapeB\n};\n\n/// Contact ids to facilitate warm starting.\nunion b2ContactID\n{\n\tb2ContactFeature cf;\n\tuint32 key;\t\t\t\t\t///< Used to quickly compare contact ids.\n};\n\n/// A manifold point is a contact point belonging to a contact\n/// manifold. It holds details related to the geometry and dynamics\n/// of the contact points.\n/// The local point usage depends on the manifold type:\n/// -e_circles: the local center of circleB\n/// -e_faceA: the local center of cirlceB or the clip point of polygonB\n/// -e_faceB: the clip point of polygonA\n/// This structure is stored across time steps, so we keep it small.\n/// Note: the impulses are used for internal caching and may not\n/// provide reliable contact forces, especially for high speed collisions.\nstruct b2ManifoldPoint\n{\n\tb2Vec2 localPoint;\t\t///< usage depends on manifold type\n\tfloat32 normalImpulse;\t///< the non-penetration impulse\n\tfloat32 tangentImpulse;\t///< the friction impulse\n\tb2ContactID id;\t\t\t///< uniquely identifies a contact point between two shapes\n};\n\n/// A manifold for two touching convex shapes.\n/// Box2D supports multiple types of contact:\n/// - clip point versus plane with radius\n/// - point versus point with radius (circles)\n/// The local point usage depends on the manifold type:\n/// -e_circles: the local center of circleA\n/// -e_faceA: the center of faceA\n/// -e_faceB: the center of faceB\n/// Similarly the local normal usage:\n/// -e_circles: not used\n/// -e_faceA: the normal on polygonA\n/// -e_faceB: the normal on polygonB\n/// We store contacts in this way so that position correction can\n/// account for movement, which is critical for continuous physics.\n/// All contact scenarios must be expressed in one of these types.\n/// This structure is stored across time steps, so we keep it small.\nstruct b2Manifold\n{\n\tenum Type\n\t{\n\t\te_circles,\n\t\te_faceA,\n\t\te_faceB\n\t};\n\n\tb2ManifoldPoint points[b2_maxManifoldPoints];\t///< the points of contact\n\tb2Vec2 localNormal;\t\t\t\t\t\t\t\t///< not use for Type::e_points\n\tb2Vec2 localPoint;\t\t\t\t\t\t\t\t///< usage depends on manifold type\n\tType type;\n\tint32 pointCount;\t\t\t\t\t\t\t\t///< the number of manifold points\n};\n\n/// This is used to compute the current state of a contact manifold.\nstruct b2WorldManifold\n{\n\t/// Evaluate the manifold with supplied transforms. This assumes\n\t/// modest motion from the original state. This does not change the\n\t/// point count, impulses, etc. The radii must come from the shapes\n\t/// that generated the manifold.\n\tvoid Initialize(const b2Manifold* manifold,\n\t\t\t\t\tconst b2Transform& xfA, float32 radiusA,\n\t\t\t\t\tconst b2Transform& xfB, float32 radiusB);\n\n\tb2Vec2 normal;\t\t\t\t\t\t\t\t///< world vector pointing from A to B\n\tb2Vec2 points[b2_maxManifoldPoints];\t\t///< world contact point (point of intersection)\n\tfloat32 separations[b2_maxManifoldPoints];\t///< a negative value indicates overlap, in meters\n};\n\n/// This is used for determining the state of contact points.\nenum b2PointState\n{\n\tb2_nullState,\t\t///< point does not exist\n\tb2_addState,\t\t///< point was added in the update\n\tb2_persistState,\t///< point persisted across the update\n\tb2_removeState\t\t///< point was removed in the update\n};\n\n/// Compute the point states given two manifolds. The states pertain to the transition from manifold1\n/// to manifold2. So state1 is either persist or remove while state2 is either add or persist.\nvoid b2GetPointStates(b2PointState state1[b2_maxManifoldPoints], b2PointState state2[b2_maxManifoldPoints],\n\t\t\t\t\t  const b2Manifold* manifold1, const b2Manifold* manifold2);\n\n/// Used for computing contact manifolds.\nstruct b2ClipVertex\n{\n\tb2Vec2 v;\n\tb2ContactID id;\n};\n\n/// Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).\nstruct b2RayCastInput\n{\n\tb2Vec2 p1, p2;\n\tfloat32 maxFraction;\n};\n\n/// Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2\n/// come from b2RayCastInput.\nstruct b2RayCastOutput\n{\n\tb2Vec2 normal;\n\tfloat32 fraction;\n};\n\n/// An axis aligned bounding box.\nstruct b2AABB\n{\n\t/// Verify that the bounds are sorted.\n\tbool IsValid() const;\n\n\t/// Get the center of the AABB.\n\tb2Vec2 GetCenter() const\n\t{\n\t\treturn 0.5f * (lowerBound + upperBound);\n\t}\n\n\t/// Get the extents of the AABB (half-widths).\n\tb2Vec2 GetExtents() const\n\t{\n\t\treturn 0.5f * (upperBound - lowerBound);\n\t}\n\n\t/// Get the perimeter length\n\tfloat32 GetPerimeter() const\n\t{\n\t\tfloat32 wx = upperBound.x - lowerBound.x;\n\t\tfloat32 wy = upperBound.y - lowerBound.y;\n\t\treturn 2.0f * (wx + wy);\n\t}\n\n\t/// Combine an AABB into this one.\n\tvoid Combine(const b2AABB& aabb)\n\t{\n\t\tlowerBound = b2Min(lowerBound, aabb.lowerBound);\n\t\tupperBound = b2Max(upperBound, aabb.upperBound);\n\t}\n\n\t/// Combine two AABBs into this one.\n\tvoid Combine(const b2AABB& aabb1, const b2AABB& aabb2)\n\t{\n\t\tlowerBound = b2Min(aabb1.lowerBound, aabb2.lowerBound);\n\t\tupperBound = b2Max(aabb1.upperBound, aabb2.upperBound);\n\t}\n\n\t/// Does this aabb contain the provided AABB.\n\tbool Contains(const b2AABB& aabb) const\n\t{\n\t\tbool result = true;\n\t\tresult = result && lowerBound.x <= aabb.lowerBound.x;\n\t\tresult = result && lowerBound.y <= aabb.lowerBound.y;\n\t\tresult = result && aabb.upperBound.x <= upperBound.x;\n\t\tresult = result && aabb.upperBound.y <= upperBound.y;\n\t\treturn result;\n\t}\n\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input) const;\n\n\tb2Vec2 lowerBound;\t///< the lower vertex\n\tb2Vec2 upperBound;\t///< the upper vertex\n};\n\n/// Compute the collision manifold between two circles.\nvoid b2CollideCircles(b2Manifold* manifold,\n\t\t\t\t\t  const b2CircleShape* circleA, const b2Transform& xfA,\n\t\t\t\t\t  const b2CircleShape* circleB, const b2Transform& xfB);\n\n/// Compute the collision manifold between a polygon and a circle.\nvoid b2CollidePolygonAndCircle(b2Manifold* manifold,\n\t\t\t\t\t\t\t   const b2PolygonShape* polygonA, const b2Transform& xfA,\n\t\t\t\t\t\t\t   const b2CircleShape* circleB, const b2Transform& xfB);\n\n/// Compute the collision manifold between two polygons.\nvoid b2CollidePolygons(b2Manifold* manifold,\n\t\t\t\t\t   const b2PolygonShape* polygonA, const b2Transform& xfA,\n\t\t\t\t\t   const b2PolygonShape* polygonB, const b2Transform& xfB);\n\n/// Compute the collision manifold between an edge and a circle.\nvoid b2CollideEdgeAndCircle(b2Manifold* manifold,\n\t\t\t\t\t\t\t   const b2EdgeShape* polygonA, const b2Transform& xfA,\n\t\t\t\t\t\t\t   const b2CircleShape* circleB, const b2Transform& xfB);\n\n/// Compute the collision manifold between an edge and a circle.\nvoid b2CollideEdgeAndPolygon(b2Manifold* manifold,\n\t\t\t\t\t\t\t   const b2EdgeShape* edgeA, const b2Transform& xfA,\n\t\t\t\t\t\t\t   const b2PolygonShape* circleB, const b2Transform& xfB);\n\n/// Clipping for contact manifolds.\nint32 b2ClipSegmentToLine(b2ClipVertex vOut[2], const b2ClipVertex vIn[2],\n\t\t\t\t\t\t\tconst b2Vec2& normal, float32 offset, int32 vertexIndexA);\n\n/// Determine if two generic shapes overlap.\nbool b2TestOverlap(\tconst b2Shape* shapeA, int32 indexA,\n\t\t\t\t\tconst b2Shape* shapeB, int32 indexB,\n\t\t\t\t\tconst b2Transform& xfA, const b2Transform& xfB);\n\n// ---------------- Inline Functions ------------------------------------------\n\ninline bool b2AABB::IsValid() const\n{\n\tb2Vec2 d = upperBound - lowerBound;\n\tbool valid = d.x >= 0.0f && d.y >= 0.0f;\n\tvalid = valid && lowerBound.IsValid() && upperBound.IsValid();\n\treturn valid;\n}\n\ninline bool b2TestOverlap(const b2AABB& a, const b2AABB& b)\n{\n\tb2Vec2 d1, d2;\n\td1 = b.lowerBound - a.upperBound;\n\td2 = a.lowerBound - b.upperBound;\n\n\tif (d1.x > 0.0f || d1.y > 0.0f)\n\t\treturn false;\n\n\tif (d2.x > 0.0f || d2.y > 0.0f)\n\t\treturn false;\n\n\treturn true;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_FRICTION_JOINT_H\n#define B2_FRICTION_JOINT_H\n\n#include <Box2D/Dynamics/Joints/b2Joint.h>\n\n/// Friction joint definition.\nstruct b2FrictionJointDef : public b2JointDef\n{\n\tb2FrictionJointDef()\n\t{\n\t\ttype = e_frictionJoint;\n\t\tlocalAnchorA.SetZero();\n\t\tlocalAnchorB.SetZero();\n\t\tmaxForce = 0.0f;\n\t\tmaxTorque = 0.0f;\n\t}\n\n\t/// Initialize the bodies, anchors, axis, and reference angle using the world\n\t/// anchor and world axis.\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);\n\n\t/// The local anchor point relative to bodyA's origin.\n\tb2Vec2 localAnchorA;\n\n\t/// The local anchor point relative to bodyB's origin.\n\tb2Vec2 localAnchorB;\n\n\t/// The maximum friction force in N.\n\tfloat32 maxForce;\n\n\t/// The maximum friction torque in N-m.\n\tfloat32 maxTorque;\n};\n\n/// Friction joint. This is used for top-down friction.\n/// It provides 2D translational friction and angular friction.\nclass b2FrictionJoint : public b2Joint\n{\npublic:\n\tb2Vec2 GetAnchorA() const;\n\tb2Vec2 GetAnchorB() const;\n\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\n\n\t/// The local anchor point relative to bodyA's origin.\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\n\n\t/// The local anchor point relative to bodyB's origin.\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\n\n\t/// Set the maximum friction force in N.\n\tvoid SetMaxForce(float32 force);\n\n\t/// Get the maximum friction force in N.\n\tfloat32 GetMaxForce() const;\n\n\t/// Set the maximum friction torque in N*m.\n\tvoid SetMaxTorque(float32 torque);\n\n\t/// Get the maximum friction torque in N*m.\n\tfloat32 GetMaxTorque() const;\n\n\t/// Dump joint to dmLog\n\tvoid Dump();\n\nprotected:\n\n\tfriend class b2Joint;\n\n\tb2FrictionJoint(const b2FrictionJointDef* def);\n\n\tvoid InitVelocityConstraints(const b2SolverData& data);\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\n\tbool SolvePositionConstraints(const b2SolverData& data);\n\n\tb2Vec2 m_localAnchorA;\n\tb2Vec2 m_localAnchorB;\n\n\t// Solver shared\n\tb2Vec2 m_linearImpulse;\n\tfloat32 m_angularImpulse;\n\tfloat32 m_maxForce;\n\tfloat32 m_maxTorque;\n\n\t// Solver temp\n\tint32 m_indexA;\n\tint32 m_indexB;\n\tb2Vec2 m_rA;\n\tb2Vec2 m_rB;\n\tb2Vec2 m_localCenterA;\n\tb2Vec2 m_localCenterB;\n\tfloat32 m_invMassA;\n\tfloat32 m_invMassB;\n\tfloat32 m_invIA;\n\tfloat32 m_invIB;\n\tb2Mat22 m_linearMass;\n\tfloat32 m_angularMass;\n};\n\n#endif\n","/*\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_PRISMATIC_JOINT_H\n#define B2_PRISMATIC_JOINT_H\n\n#include <Box2D/Dynamics/Joints/b2Joint.h>\n\n/// Prismatic joint definition. This requires defining a line of\n/// motion using an axis and an anchor point. The definition uses local\n/// anchor points and a local axis so that the initial configuration\n/// can violate the constraint slightly. The joint translation is zero\n/// when the local anchor points coincide in world space. Using local\n/// anchors and a local axis helps when saving and loading a game.\nstruct b2PrismaticJointDef : public b2JointDef\n{\n\tb2PrismaticJointDef()\n\t{\n\t\ttype = e_prismaticJoint;\n\t\tlocalAnchorA.SetZero();\n\t\tlocalAnchorB.SetZero();\n\t\tlocalAxisA.Set(1.0f, 0.0f);\n\t\treferenceAngle = 0.0f;\n\t\tenableLimit = false;\n\t\tlowerTranslation = 0.0f;\n\t\tupperTranslation = 0.0f;\n\t\tenableMotor = false;\n\t\tmaxMotorForce = 0.0f;\n\t\tmotorSpeed = 0.0f;\n\t}\n\n\t/// Initialize the bodies, anchors, axis, and reference angle using the world\n\t/// anchor and unit world axis.\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor, const b2Vec2& axis);\n\n\t/// The local anchor point relative to bodyA's origin.\n\tb2Vec2 localAnchorA;\n\n\t/// The local anchor point relative to bodyB's origin.\n\tb2Vec2 localAnchorB;\n\n\t/// The local translation unit axis in bodyA.\n\tb2Vec2 localAxisA;\n\n\t/// The constrained angle between the bodies: bodyB_angle - bodyA_angle.\n\tfloat32 referenceAngle;\n\n\t/// Enable/disable the joint limit.\n\tbool enableLimit;\n\n\t/// The lower translation limit, usually in meters.\n\tfloat32 lowerTranslation;\n\n\t/// The upper translation limit, usually in meters.\n\tfloat32 upperTranslation;\n\n\t/// Enable/disable the joint motor.\n\tbool enableMotor;\n\n\t/// The maximum motor torque, usually in N-m.\n\tfloat32 maxMotorForce;\n\n\t/// The desired motor speed in radians per second.\n\tfloat32 motorSpeed;\n};\n\n/// A prismatic joint. This joint provides one degree of freedom: translation\n/// along an axis fixed in bodyA. Relative rotation is prevented. You can\n/// use a joint limit to restrict the range of motion and a joint motor to\n/// drive the motion or to model joint friction.\nclass b2PrismaticJoint : public b2Joint\n{\npublic:\n\tb2Vec2 GetAnchorA() const;\n\tb2Vec2 GetAnchorB() const;\n\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\n\n\t/// The local anchor point relative to bodyA's origin.\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\n\n\t/// The local anchor point relative to bodyB's origin.\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\n\n\t/// The local joint axis relative to bodyA.\n\tconst b2Vec2& GetLocalAxisA() const { return m_localXAxisA; }\n\n\t/// Get the reference angle.\n\tfloat32 GetReferenceAngle() const { return m_referenceAngle; }\n\n\t/// Get the current joint translation, usually in meters.\n\tfloat32 GetJointTranslation() const;\n\n\t/// Get the current joint translation speed, usually in meters per second.\n\tfloat32 GetJointSpeed() const;\n\n\t/// Is the joint limit enabled?\n\tbool IsLimitEnabled() const;\n\n\t/// Enable/disable the joint limit.\n\tvoid EnableLimit(bool flag);\n\n\t/// Get the lower joint limit, usually in meters.\n\tfloat32 GetLowerLimit() const;\n\n\t/// Get the upper joint limit, usually in meters.\n\tfloat32 GetUpperLimit() const;\n\n\t/// Set the joint limits, usually in meters.\n\tvoid SetLimits(float32 lower, float32 upper);\n\n\t/// Is the joint motor enabled?\n\tbool IsMotorEnabled() const;\n\n\t/// Enable/disable the joint motor.\n\tvoid EnableMotor(bool flag);\n\n\t/// Set the motor speed, usually in meters per second.\n\tvoid SetMotorSpeed(float32 speed);\n\n\t/// Get the motor speed, usually in meters per second.\n\tfloat32 GetMotorSpeed() const;\n\n\t/// Set the maximum motor force, usually in N.\n\tvoid SetMaxMotorForce(float32 force);\n\tfloat32 GetMaxMotorForce() const { return m_maxMotorForce; }\n\n\t/// Get the current motor force given the inverse time step, usually in N.\n\tfloat32 GetMotorForce(float32 inv_dt) const;\n\n\t/// Dump to b2Log\n\tvoid Dump();\n\nprotected:\n\tfriend class b2Joint;\n\tfriend class b2GearJoint;\n\tb2PrismaticJoint(const b2PrismaticJointDef* def);\n\n\tvoid InitVelocityConstraints(const b2SolverData& data);\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\n\tbool SolvePositionConstraints(const b2SolverData& data);\n\n\t// Solver shared\n\tb2Vec2 m_localAnchorA;\n\tb2Vec2 m_localAnchorB;\n\tb2Vec2 m_localXAxisA;\n\tb2Vec2 m_localYAxisA;\n\tfloat32 m_referenceAngle;\n\tb2Vec3 m_impulse;\n\tfloat32 m_motorImpulse;\n\tfloat32 m_lowerTranslation;\n\tfloat32 m_upperTranslation;\n\tfloat32 m_maxMotorForce;\n\tfloat32 m_motorSpeed;\n\tbool m_enableLimit;\n\tbool m_enableMotor;\n\tb2LimitState m_limitState;\n\n\t// Solver temp\n\tint32 m_indexA;\n\tint32 m_indexB;\n\tb2Vec2 m_localCenterA;\n\tb2Vec2 m_localCenterB;\n\tfloat32 m_invMassA;\n\tfloat32 m_invMassB;\n\tfloat32 m_invIA;\n\tfloat32 m_invIB;\n\tb2Vec2 m_axis, m_perp;\n\tfloat32 m_s1, m_s2;\n\tfloat32 m_a1, m_a2;\n\tb2Mat33 m_K;\n\tfloat32 m_motorMass;\n};\n\ninline float32 b2PrismaticJoint::GetMotorSpeed() const\n{\n\treturn m_motorSpeed;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_WORLD_H\n#define B2_WORLD_H\n\n#include <Box2D/Common/b2Math.h>\n#include <Box2D/Common/b2BlockAllocator.h>\n#include <Box2D/Common/b2StackAllocator.h>\n#include <Box2D/Dynamics/b2ContactManager.h>\n#include <Box2D/Dynamics/b2WorldCallbacks.h>\n#include <Box2D/Dynamics/b2TimeStep.h>\n\nstruct b2AABB;\nstruct b2BodyDef;\nstruct b2Color;\nstruct b2JointDef;\nclass b2Body;\nclass b2Draw;\nclass b2Fixture;\nclass b2Joint;\n\n/// The world class manages all physics entities, dynamic simulation,\n/// and asynchronous queries. The world also contains efficient memory\n/// management facilities.\nclass b2World\n{\npublic:\n\t/// Construct a world object.\n\t/// @param gravity the world gravity vector.\n\tb2World(const b2Vec2& gravity);\n\n\t/// Destruct the world. All physics entities are destroyed and all heap memory is released.\n\t~b2World();\n\n\t/// Register a destruction listener. The listener is owned by you and must\n\t/// remain in scope.\n\tvoid SetDestructionListener(b2DestructionListener* listener);\n\n\t/// Register a contact filter to provide specific control over collision.\n\t/// Otherwise the default filter is used (b2_defaultFilter). The listener is\n\t/// owned by you and must remain in scope. \n\tvoid SetContactFilter(b2ContactFilter* filter);\n\n\t/// Register a contact event listener. The listener is owned by you and must\n\t/// remain in scope.\n\tvoid SetContactListener(b2ContactListener* listener);\n\n\t/// Register a routine for debug drawing. The debug draw functions are called\n\t/// inside with b2World::DrawDebugData method. The debug draw object is owned\n\t/// by you and must remain in scope.\n\tvoid SetDebugDraw(b2Draw* debugDraw);\n\n\t/// Create a rigid body given a definition. No reference to the definition\n\t/// is retained.\n\t/// @warning This function is locked during callbacks.\n\tb2Body* CreateBody(const b2BodyDef* def);\n\n\t/// Destroy a rigid body given a definition. No reference to the definition\n\t/// is retained. This function is locked during callbacks.\n\t/// @warning This automatically deletes all associated shapes and joints.\n\t/// @warning This function is locked during callbacks.\n\tvoid DestroyBody(b2Body* body);\n\n\t/// Create a joint to constrain bodies together. No reference to the definition\n\t/// is retained. This may cause the connected bodies to cease colliding.\n\t/// @warning This function is locked during callbacks.\n\tb2Joint* CreateJoint(const b2JointDef* def);\n\n\t/// Destroy a joint. This may cause the connected bodies to begin colliding.\n\t/// @warning This function is locked during callbacks.\n\tvoid DestroyJoint(b2Joint* joint);\n\n\t/// Take a time step. This performs collision detection, integration,\n\t/// and constraint solution.\n\t/// @param timeStep the amount of time to simulate, this should not vary.\n\t/// @param velocityIterations for the velocity constraint solver.\n\t/// @param positionIterations for the position constraint solver.\n\tvoid Step(\tfloat32 timeStep,\n\t\t\t\tint32 velocityIterations,\n\t\t\t\tint32 positionIterations);\n\n\t/// Manually clear the force buffer on all bodies. By default, forces are cleared automatically\n\t/// after each call to Step. The default behavior is modified by calling SetAutoClearForces.\n\t/// The purpose of this function is to support sub-stepping. Sub-stepping is often used to maintain\n\t/// a fixed sized time step under a variable frame-rate.\n\t/// When you perform sub-stepping you will disable auto clearing of forces and instead call\n\t/// ClearForces after all sub-steps are complete in one pass of your game loop.\n\t/// @see SetAutoClearForces\n\tvoid ClearForces();\n\n\t/// Call this to draw shapes and other debug draw data. This is intentionally non-const.\n\tvoid DrawDebugData();\n\n\t/// Query the world for all fixtures that potentially overlap the\n\t/// provided AABB.\n\t/// @param callback a user implemented callback class.\n\t/// @param aabb the query box.\n\tvoid QueryAABB(b2QueryCallback* callback, const b2AABB& aabb) const;\n\n\t/// Ray-cast the world for all fixtures in the path of the ray. Your callback\n\t/// controls whether you get the closest point, any point, or n-points.\n\t/// The ray-cast ignores shapes that contain the starting point.\n\t/// @param callback a user implemented callback class.\n\t/// @param point1 the ray starting point\n\t/// @param point2 the ray ending point\n\tvoid RayCast(b2RayCastCallback* callback, const b2Vec2& point1, const b2Vec2& point2) const;\n\n\t/// Get the world body list. With the returned body, use b2Body::GetNext to get\n\t/// the next body in the world list. A NULL body indicates the end of the list.\n\t/// @return the head of the world body list.\n\tb2Body* GetBodyList();\n\tconst b2Body* GetBodyList() const;\n\n\t/// Get the world joint list. With the returned joint, use b2Joint::GetNext to get\n\t/// the next joint in the world list. A NULL joint indicates the end of the list.\n\t/// @return the head of the world joint list.\n\tb2Joint* GetJointList();\n\tconst b2Joint* GetJointList() const;\n\n\t/// Get the world contact list. With the returned contact, use b2Contact::GetNext to get\n\t/// the next contact in the world list. A NULL contact indicates the end of the list.\n\t/// @return the head of the world contact list.\n\t/// @warning contacts are created and destroyed in the middle of a time step.\n\t/// Use b2ContactListener to avoid missing contacts.\n\tb2Contact* GetContactList();\n\tconst b2Contact* GetContactList() const;\n\n\t/// Enable/disable sleep.\n\tvoid SetAllowSleeping(bool flag);\n\tbool GetAllowSleeping() const { return m_allowSleep; }\n\n\t/// Enable/disable warm starting. For testing.\n\tvoid SetWarmStarting(bool flag) { m_warmStarting = flag; }\n\tbool GetWarmStarting() const { return m_warmStarting; }\n\n\t/// Enable/disable continuous physics. For testing.\n\tvoid SetContinuousPhysics(bool flag) { m_continuousPhysics = flag; }\n\tbool GetContinuousPhysics() const { return m_continuousPhysics; }\n\n\t/// Enable/disable single stepped continuous physics. For testing.\n\tvoid SetSubStepping(bool flag) { m_subStepping = flag; }\n\tbool GetSubStepping() const { return m_subStepping; }\n\n\t/// Get the number of broad-phase proxies.\n\tint32 GetProxyCount() const;\n\n\t/// Get the number of bodies.\n\tint32 GetBodyCount() const;\n\n\t/// Get the number of joints.\n\tint32 GetJointCount() const;\n\n\t/// Get the number of contacts (each may have 0 or more contact points).\n\tint32 GetContactCount() const;\n\n\t/// Get the height of the dynamic tree.\n\tint32 GetTreeHeight() const;\n\n\t/// Get the balance of the dynamic tree.\n\tint32 GetTreeBalance() const;\n\n\t/// Get the quality metric of the dynamic tree. The smaller the better.\n\t/// The minimum is 1.\n\tfloat32 GetTreeQuality() const;\n\n\t/// Change the global gravity vector.\n\tvoid SetGravity(const b2Vec2& gravity);\n\t\n\t/// Get the global gravity vector.\n\tb2Vec2 GetGravity() const;\n\n\t/// Is the world locked (in the middle of a time step).\n\tbool IsLocked() const;\n\n\t/// Set flag to control automatic clearing of forces after each time step.\n\tvoid SetAutoClearForces(bool flag);\n\n\t/// Get the flag that controls automatic clearing of forces after each time step.\n\tbool GetAutoClearForces() const;\n\n\t/// Shift the world origin. Useful for large worlds.\n\t/// The body shift formula is: position -= newOrigin\n\t/// @param newOrigin the new origin with respect to the old origin\n\tvoid ShiftOrigin(const b2Vec2& newOrigin);\n\n\t/// Get the contact manager for testing.\n\tconst b2ContactManager& GetContactManager() const;\n\n\t/// Get the current profile.\n\tconst b2Profile& GetProfile() const;\n\n\t/// Dump the world into the log file.\n\t/// @warning this should be called outside of a time step.\n\tvoid Dump();\n\nprivate:\n\n\t// m_flags\n\tenum\n\t{\n\t\te_newFixture\t= 0x0001,\n\t\te_locked\t\t= 0x0002,\n\t\te_clearForces\t= 0x0004\n\t};\n\n\tfriend class b2Body;\n\tfriend class b2Fixture;\n\tfriend class b2ContactManager;\n\tfriend class b2Controller;\n\n\tvoid Solve(const b2TimeStep& step);\n\tvoid SolveTOI(const b2TimeStep& step);\n\n\tvoid DrawJoint(b2Joint* joint);\n\tvoid DrawShape(b2Fixture* shape, const b2Transform& xf, const b2Color& color);\n\n\tb2BlockAllocator m_blockAllocator;\n\tb2StackAllocator m_stackAllocator;\n\n\tint32 m_flags;\n\n\tb2ContactManager m_contactManager;\n\n\tb2Body* m_bodyList;\n\tb2Joint* m_jointList;\n\n\tint32 m_bodyCount;\n\tint32 m_jointCount;\n\n\tb2Vec2 m_gravity;\n\tbool m_allowSleep;\n\n\tb2DestructionListener* m_destructionListener;\n\tb2Draw* g_debugDraw;\n\n\t// This is used to compute the time step ratio to\n\t// support a variable time step.\n\tfloat32 m_inv_dt0;\n\n\t// These are for debugging the solver.\n\tbool m_warmStarting;\n\tbool m_continuousPhysics;\n\tbool m_subStepping;\n\n\tbool m_stepComplete;\n\n\tb2Profile m_profile;\n};\n\ninline b2Body* b2World::GetBodyList()\n{\n\treturn m_bodyList;\n}\n\ninline const b2Body* b2World::GetBodyList() const\n{\n\treturn m_bodyList;\n}\n\ninline b2Joint* b2World::GetJointList()\n{\n\treturn m_jointList;\n}\n\ninline const b2Joint* b2World::GetJointList() const\n{\n\treturn m_jointList;\n}\n\ninline b2Contact* b2World::GetContactList()\n{\n\treturn m_contactManager.m_contactList;\n}\n\ninline const b2Contact* b2World::GetContactList() const\n{\n\treturn m_contactManager.m_contactList;\n}\n\ninline int32 b2World::GetBodyCount() const\n{\n\treturn m_bodyCount;\n}\n\ninline int32 b2World::GetJointCount() const\n{\n\treturn m_jointCount;\n}\n\ninline int32 b2World::GetContactCount() const\n{\n\treturn m_contactManager.m_contactCount;\n}\n\ninline void b2World::SetGravity(const b2Vec2& gravity)\n{\n\tm_gravity = gravity;\n}\n\ninline b2Vec2 b2World::GetGravity() const\n{\n\treturn m_gravity;\n}\n\ninline bool b2World::IsLocked() const\n{\n\treturn (m_flags & e_locked) == e_locked;\n}\n\ninline void b2World::SetAutoClearForces(bool flag)\n{\n\tif (flag)\n\t{\n\t\tm_flags |= e_clearForces;\n\t}\n\telse\n\t{\n\t\tm_flags &= ~e_clearForces;\n\t}\n}\n\n/// Get the flag that controls automatic clearing of forces after each time step.\ninline bool b2World::GetAutoClearForces() const\n{\n\treturn (m_flags & e_clearForces) == e_clearForces;\n}\n\ninline const b2ContactManager& b2World::GetContactManager() const\n{\n\treturn m_contactManager;\n}\n\ninline const b2Profile& b2World::GetProfile() const\n{\n\treturn m_profile;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_WHEEL_JOINT_H\n#define B2_WHEEL_JOINT_H\n\n#include <Box2D/Dynamics/Joints/b2Joint.h>\n\n/// Wheel joint definition. This requires defining a line of\n/// motion using an axis and an anchor point. The definition uses local\n/// anchor points and a local axis so that the initial configuration\n/// can violate the constraint slightly. The joint translation is zero\n/// when the local anchor points coincide in world space. Using local\n/// anchors and a local axis helps when saving and loading a game.\nstruct b2WheelJointDef : public b2JointDef\n{\n\tb2WheelJointDef()\n\t{\n\t\ttype = e_wheelJoint;\n\t\tlocalAnchorA.SetZero();\n\t\tlocalAnchorB.SetZero();\n\t\tlocalAxisA.Set(1.0f, 0.0f);\n\t\tenableMotor = false;\n\t\tmaxMotorTorque = 0.0f;\n\t\tmotorSpeed = 0.0f;\n\t\tfrequencyHz = 2.0f;\n\t\tdampingRatio = 0.7f;\n\t}\n\n\t/// Initialize the bodies, anchors, axis, and reference angle using the world\n\t/// anchor and world axis.\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor, const b2Vec2& axis);\n\n\t/// The local anchor point relative to bodyA's origin.\n\tb2Vec2 localAnchorA;\n\n\t/// The local anchor point relative to bodyB's origin.\n\tb2Vec2 localAnchorB;\n\n\t/// The local translation axis in bodyA.\n\tb2Vec2 localAxisA;\n\n\t/// Enable/disable the joint motor.\n\tbool enableMotor;\n\n\t/// The maximum motor torque, usually in N-m.\n\tfloat32 maxMotorTorque;\n\n\t/// The desired motor speed in radians per second.\n\tfloat32 motorSpeed;\n\n\t/// Suspension frequency, zero indicates no suspension\n\tfloat32 frequencyHz;\n\n\t/// Suspension damping ratio, one indicates critical damping\n\tfloat32 dampingRatio;\n};\n\n/// A wheel joint. This joint provides two degrees of freedom: translation\n/// along an axis fixed in bodyA and rotation in the plane. You can use a\n/// joint limit to restrict the range of motion and a joint motor to drive\n/// the rotation or to model rotational friction.\n/// This joint is designed for vehicle suspensions.\nclass b2WheelJoint : public b2Joint\n{\npublic:\n\tb2Vec2 GetAnchorA() const;\n\tb2Vec2 GetAnchorB() const;\n\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\n\n\t/// The local anchor point relative to bodyA's origin.\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\n\n\t/// The local anchor point relative to bodyB's origin.\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\n\n\t/// The local joint axis relative to bodyA.\n\tconst b2Vec2& GetLocalAxisA() const { return m_localXAxisA; }\n\n\t/// Get the current joint translation, usually in meters.\n\tfloat32 GetJointTranslation() const;\n\n\t/// Get the current joint translation speed, usually in meters per second.\n\tfloat32 GetJointSpeed() const;\n\n\t/// Is the joint motor enabled?\n\tbool IsMotorEnabled() const;\n\n\t/// Enable/disable the joint motor.\n\tvoid EnableMotor(bool flag);\n\n\t/// Set the motor speed, usually in radians per second.\n\tvoid SetMotorSpeed(float32 speed);\n\n\t/// Get the motor speed, usually in radians per second.\n\tfloat32 GetMotorSpeed() const;\n\n\t/// Set/Get the maximum motor force, usually in N-m.\n\tvoid SetMaxMotorTorque(float32 torque);\n\tfloat32 GetMaxMotorTorque() const;\n\n\t/// Get the current motor torque given the inverse time step, usually in N-m.\n\tfloat32 GetMotorTorque(float32 inv_dt) const;\n\n\t/// Set/Get the spring frequency in hertz. Setting the frequency to zero disables the spring.\n\tvoid SetSpringFrequencyHz(float32 hz);\n\tfloat32 GetSpringFrequencyHz() const;\n\n\t/// Set/Get the spring damping ratio\n\tvoid SetSpringDampingRatio(float32 ratio);\n\tfloat32 GetSpringDampingRatio() const;\n\n\t/// Dump to b2Log\n\tvoid Dump();\n\nprotected:\n\n\tfriend class b2Joint;\n\tb2WheelJoint(const b2WheelJointDef* def);\n\n\tvoid InitVelocityConstraints(const b2SolverData& data);\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\n\tbool SolvePositionConstraints(const b2SolverData& data);\n\n\tfloat32 m_frequencyHz;\n\tfloat32 m_dampingRatio;\n\n\t// Solver shared\n\tb2Vec2 m_localAnchorA;\n\tb2Vec2 m_localAnchorB;\n\tb2Vec2 m_localXAxisA;\n\tb2Vec2 m_localYAxisA;\n\n\tfloat32 m_impulse;\n\tfloat32 m_motorImpulse;\n\tfloat32 m_springImpulse;\n\n\tfloat32 m_maxMotorTorque;\n\tfloat32 m_motorSpeed;\n\tbool m_enableMotor;\n\n\t// Solver temp\n\tint32 m_indexA;\n\tint32 m_indexB;\n\tb2Vec2 m_localCenterA;\n\tb2Vec2 m_localCenterB;\n\tfloat32 m_invMassA;\n\tfloat32 m_invMassB;\n\tfloat32 m_invIA;\n\tfloat32 m_invIB;\n\n\tb2Vec2 m_ax, m_ay;\n\tfloat32 m_sAx, m_sBx;\n\tfloat32 m_sAy, m_sBy;\n\n\tfloat32 m_mass;\n\tfloat32 m_motorMass;\n\tfloat32 m_springMass;\n\n\tfloat32 m_bias;\n\tfloat32 m_gamma;\n};\n\ninline float32 b2WheelJoint::GetMotorSpeed() const\n{\n\treturn m_motorSpeed;\n}\n\ninline float32 b2WheelJoint::GetMaxMotorTorque() const\n{\n\treturn m_maxMotorTorque;\n}\n\ninline void b2WheelJoint::SetSpringFrequencyHz(float32 hz)\n{\n\tm_frequencyHz = hz;\n}\n\ninline float32 b2WheelJoint::GetSpringFrequencyHz() const\n{\n\treturn m_frequencyHz;\n}\n\ninline void b2WheelJoint::SetSpringDampingRatio(float32 ratio)\n{\n\tm_dampingRatio = ratio;\n}\n\ninline float32 b2WheelJoint::GetSpringDampingRatio() const\n{\n\treturn m_dampingRatio;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_CIRCLE_SHAPE_H\n#define B2_CIRCLE_SHAPE_H\n\n#include <Box2D/Collision/Shapes/b2Shape.h>\n\n/// A circle shape.\nclass b2CircleShape : public b2Shape\n{\npublic:\n\tb2CircleShape();\n\n\t/// Implement b2Shape.\n\tb2Shape* Clone(b2BlockAllocator* allocator) const;\n\n\t/// @see b2Shape::GetChildCount\n\tint32 GetChildCount() const;\n\n\t/// Implement b2Shape.\n\tbool TestPoint(const b2Transform& transform, const b2Vec2& p) const;\n\n\t/// Implement b2Shape.\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,\n\t\t\t\tconst b2Transform& transform, int32 childIndex) const;\n\n\t/// @see b2Shape::ComputeAABB\n\tvoid ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;\n\n\t/// @see b2Shape::ComputeMass\n\tvoid ComputeMass(b2MassData* massData, float32 density) const;\n\n\t/// Get the supporting vertex index in the given direction.\n\tint32 GetSupport(const b2Vec2& d) const;\n\n\t/// Get the supporting vertex in the given direction.\n\tconst b2Vec2& GetSupportVertex(const b2Vec2& d) const;\n\n\t/// Get the vertex count.\n\tint32 GetVertexCount() const { return 1; }\n\n\t/// Get a vertex by index. Used by b2Distance.\n\tconst b2Vec2& GetVertex(int32 index) const;\n\n\t/// Position\n\tb2Vec2 m_p;\n};\n\ninline b2CircleShape::b2CircleShape()\n{\n\tm_type = e_circle;\n\tm_radius = 0.0f;\n\tm_p.SetZero();\n}\n\ninline int32 b2CircleShape::GetSupport(const b2Vec2 &d) const\n{\n\tB2_NOT_USED(d);\n\treturn 0;\n}\n\ninline const b2Vec2& b2CircleShape::GetSupportVertex(const b2Vec2 &d) const\n{\n\tB2_NOT_USED(d);\n\treturn m_p;\n}\n\ninline const b2Vec2& b2CircleShape::GetVertex(int32 index) const\n{\n\tB2_NOT_USED(index);\n\tb2Assert(index == 0);\n\treturn m_p;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_WELD_JOINT_H\n#define B2_WELD_JOINT_H\n\n#include <Box2D/Dynamics/Joints/b2Joint.h>\n\n/// Weld joint definition. You need to specify local anchor points\n/// where they are attached and the relative body angle. The position\n/// of the anchor points is important for computing the reaction torque.\nstruct b2WeldJointDef : public b2JointDef\n{\n\tb2WeldJointDef()\n\t{\n\t\ttype = e_weldJoint;\n\t\tlocalAnchorA.Set(0.0f, 0.0f);\n\t\tlocalAnchorB.Set(0.0f, 0.0f);\n\t\treferenceAngle = 0.0f;\n\t\tfrequencyHz = 0.0f;\n\t\tdampingRatio = 0.0f;\n\t}\n\n\t/// Initialize the bodies, anchors, and reference angle using a world\n\t/// anchor point.\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);\n\n\t/// The local anchor point relative to bodyA's origin.\n\tb2Vec2 localAnchorA;\n\n\t/// The local anchor point relative to bodyB's origin.\n\tb2Vec2 localAnchorB;\n\n\t/// The bodyB angle minus bodyA angle in the reference state (radians).\n\tfloat32 referenceAngle;\n\t\n\t/// The mass-spring-damper frequency in Hertz. Rotation only.\n\t/// Disable softness with a value of 0.\n\tfloat32 frequencyHz;\n\n\t/// The damping ratio. 0 = no damping, 1 = critical damping.\n\tfloat32 dampingRatio;\n};\n\n/// A weld joint essentially glues two bodies together. A weld joint may\n/// distort somewhat because the island constraint solver is approximate.\nclass b2WeldJoint : public b2Joint\n{\npublic:\n\tb2Vec2 GetAnchorA() const;\n\tb2Vec2 GetAnchorB() const;\n\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\n\n\t/// The local anchor point relative to bodyA's origin.\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\n\n\t/// The local anchor point relative to bodyB's origin.\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\n\n\t/// Get the reference angle.\n\tfloat32 GetReferenceAngle() const { return m_referenceAngle; }\n\n\t/// Set/get frequency in Hz.\n\tvoid SetFrequency(float32 hz) { m_frequencyHz = hz; }\n\tfloat32 GetFrequency() const { return m_frequencyHz; }\n\n\t/// Set/get damping ratio.\n\tvoid SetDampingRatio(float32 ratio) { m_dampingRatio = ratio; }\n\tfloat32 GetDampingRatio() const { return m_dampingRatio; }\n\n\t/// Dump to b2Log\n\tvoid Dump();\n\nprotected:\n\n\tfriend class b2Joint;\n\n\tb2WeldJoint(const b2WeldJointDef* def);\n\n\tvoid InitVelocityConstraints(const b2SolverData& data);\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\n\tbool SolvePositionConstraints(const b2SolverData& data);\n\n\tfloat32 m_frequencyHz;\n\tfloat32 m_dampingRatio;\n\tfloat32 m_bias;\n\n\t// Solver shared\n\tb2Vec2 m_localAnchorA;\n\tb2Vec2 m_localAnchorB;\n\tfloat32 m_referenceAngle;\n\tfloat32 m_gamma;\n\tb2Vec3 m_impulse;\n\n\t// Solver temp\n\tint32 m_indexA;\n\tint32 m_indexB;\n\tb2Vec2 m_rA;\n\tb2Vec2 m_rB;\n\tb2Vec2 m_localCenterA;\n\tb2Vec2 m_localCenterB;\n\tfloat32 m_invMassA;\n\tfloat32 m_invMassB;\n\tfloat32 m_invIA;\n\tfloat32 m_invIB;\n\tb2Mat33 m_mass;\n};\n\n#endif\n","/*\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_GEAR_JOINT_H\n#define B2_GEAR_JOINT_H\n\n#include <Box2D/Dynamics/Joints/b2Joint.h>\n\n/// Gear joint definition. This definition requires two existing\n/// revolute or prismatic joints (any combination will work).\nstruct b2GearJointDef : public b2JointDef\n{\n\tb2GearJointDef()\n\t{\n\t\ttype = e_gearJoint;\n\t\tjoint1 = NULL;\n\t\tjoint2 = NULL;\n\t\tratio = 1.0f;\n\t}\n\n\t/// The first revolute/prismatic joint attached to the gear joint.\n\tb2Joint* joint1;\n\n\t/// The second revolute/prismatic joint attached to the gear joint.\n\tb2Joint* joint2;\n\n\t/// The gear ratio.\n\t/// @see b2GearJoint for explanation.\n\tfloat32 ratio;\n};\n\n/// A gear joint is used to connect two joints together. Either joint\n/// can be a revolute or prismatic joint. You specify a gear ratio\n/// to bind the motions together:\n/// coordinate1 + ratio * coordinate2 = constant\n/// The ratio can be negative or positive. If one joint is a revolute joint\n/// and the other joint is a prismatic joint, then the ratio will have units\n/// of length or units of 1/length.\n/// @warning You have to manually destroy the gear joint if joint1 or joint2\n/// is destroyed.\nclass b2GearJoint : public b2Joint\n{\npublic:\n\tb2Vec2 GetAnchorA() const;\n\tb2Vec2 GetAnchorB() const;\n\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\n\n\t/// Get the first joint.\n\tb2Joint* GetJoint1() { return m_joint1; }\n\n\t/// Get the second joint.\n\tb2Joint* GetJoint2() { return m_joint2; }\n\n\t/// Set/Get the gear ratio.\n\tvoid SetRatio(float32 ratio);\n\tfloat32 GetRatio() const;\n\n\t/// Dump joint to dmLog\n\tvoid Dump();\n\nprotected:\n\n\tfriend class b2Joint;\n\tb2GearJoint(const b2GearJointDef* data);\n\n\tvoid InitVelocityConstraints(const b2SolverData& data);\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\n\tbool SolvePositionConstraints(const b2SolverData& data);\n\n\tb2Joint* m_joint1;\n\tb2Joint* m_joint2;\n\n\tb2JointType m_typeA;\n\tb2JointType m_typeB;\n\n\t// Body A is connected to body C\n\t// Body B is connected to body D\n\tb2Body* m_bodyC;\n\tb2Body* m_bodyD;\n\n\t// Solver shared\n\tb2Vec2 m_localAnchorA;\n\tb2Vec2 m_localAnchorB;\n\tb2Vec2 m_localAnchorC;\n\tb2Vec2 m_localAnchorD;\n\n\tb2Vec2 m_localAxisC;\n\tb2Vec2 m_localAxisD;\n\n\tfloat32 m_referenceAngleA;\n\tfloat32 m_referenceAngleB;\n\n\tfloat32 m_constant;\n\tfloat32 m_ratio;\n\n\tfloat32 m_impulse;\n\n\t// Solver temp\n\tint32 m_indexA, m_indexB, m_indexC, m_indexD;\n\tb2Vec2 m_lcA, m_lcB, m_lcC, m_lcD;\n\tfloat32 m_mA, m_mB, m_mC, m_mD;\n\tfloat32 m_iA, m_iB, m_iC, m_iD;\n\tb2Vec2 m_JvAC, m_JvBD;\n\tfloat32 m_JwA, m_JwB, m_JwC, m_JwD;\n\tfloat32 m_mass;\n};\n\n#endif\n","/*\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_PULLEY_JOINT_H\n#define B2_PULLEY_JOINT_H\n\n#include <Box2D/Dynamics/Joints/b2Joint.h>\n\nconst float32 b2_minPulleyLength = 2.0f;\n\n/// Pulley joint definition. This requires two ground anchors,\n/// two dynamic body anchor points, and a pulley ratio.\nstruct b2PulleyJointDef : public b2JointDef\n{\n\tb2PulleyJointDef()\n\t{\n\t\ttype = e_pulleyJoint;\n\t\tgroundAnchorA.Set(-1.0f, 1.0f);\n\t\tgroundAnchorB.Set(1.0f, 1.0f);\n\t\tlocalAnchorA.Set(-1.0f, 0.0f);\n\t\tlocalAnchorB.Set(1.0f, 0.0f);\n\t\tlengthA = 0.0f;\n\t\tlengthB = 0.0f;\n\t\tratio = 1.0f;\n\t\tcollideConnected = true;\n\t}\n\n\t/// Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB,\n\t\t\t\t\tconst b2Vec2& groundAnchorA, const b2Vec2& groundAnchorB,\n\t\t\t\t\tconst b2Vec2& anchorA, const b2Vec2& anchorB,\n\t\t\t\t\tfloat32 ratio);\n\n\t/// The first ground anchor in world coordinates. This point never moves.\n\tb2Vec2 groundAnchorA;\n\n\t/// The second ground anchor in world coordinates. This point never moves.\n\tb2Vec2 groundAnchorB;\n\n\t/// The local anchor point relative to bodyA's origin.\n\tb2Vec2 localAnchorA;\n\n\t/// The local anchor point relative to bodyB's origin.\n\tb2Vec2 localAnchorB;\n\n\t/// The a reference length for the segment attached to bodyA.\n\tfloat32 lengthA;\n\n\t/// The a reference length for the segment attached to bodyB.\n\tfloat32 lengthB;\n\n\t/// The pulley ratio, used to simulate a block-and-tackle.\n\tfloat32 ratio;\n};\n\n/// The pulley joint is connected to two bodies and two fixed ground points.\n/// The pulley supports a ratio such that:\n/// length1 + ratio * length2 <= constant\n/// Yes, the force transmitted is scaled by the ratio.\n/// Warning: the pulley joint can get a bit squirrelly by itself. They often\n/// work better when combined with prismatic joints. You should also cover the\n/// the anchor points with static shapes to prevent one side from going to\n/// zero length.\nclass b2PulleyJoint : public b2Joint\n{\npublic:\n\tb2Vec2 GetAnchorA() const;\n\tb2Vec2 GetAnchorB() const;\n\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\n\n\t/// Get the first ground anchor.\n\tb2Vec2 GetGroundAnchorA() const;\n\n\t/// Get the second ground anchor.\n\tb2Vec2 GetGroundAnchorB() const;\n\n\t/// Get the current length of the segment attached to bodyA.\n\tfloat32 GetLengthA() const;\n\n\t/// Get the current length of the segment attached to bodyB.\n\tfloat32 GetLengthB() const;\n\n\t/// Get the pulley ratio.\n\tfloat32 GetRatio() const;\n\n\t/// Get the current length of the segment attached to bodyA.\n\tfloat32 GetCurrentLengthA() const;\n\n\t/// Get the current length of the segment attached to bodyB.\n\tfloat32 GetCurrentLengthB() const;\n\n\t/// Dump joint to dmLog\n\tvoid Dump();\n\n\t/// Implement b2Joint::ShiftOrigin\n\tvoid ShiftOrigin(const b2Vec2& newOrigin);\n\nprotected:\n\n\tfriend class b2Joint;\n\tb2PulleyJoint(const b2PulleyJointDef* data);\n\n\tvoid InitVelocityConstraints(const b2SolverData& data);\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\n\tbool SolvePositionConstraints(const b2SolverData& data);\n\n\tb2Vec2 m_groundAnchorA;\n\tb2Vec2 m_groundAnchorB;\n\tfloat32 m_lengthA;\n\tfloat32 m_lengthB;\n\t\n\t// Solver shared\n\tb2Vec2 m_localAnchorA;\n\tb2Vec2 m_localAnchorB;\n\tfloat32 m_constant;\n\tfloat32 m_ratio;\n\tfloat32 m_impulse;\n\n\t// Solver temp\n\tint32 m_indexA;\n\tint32 m_indexB;\n\tb2Vec2 m_uA;\n\tb2Vec2 m_uB;\n\tb2Vec2 m_rA;\n\tb2Vec2 m_rB;\n\tb2Vec2 m_localCenterA;\n\tb2Vec2 m_localCenterB;\n\tfloat32 m_invMassA;\n\tfloat32 m_invMassB;\n\tfloat32 m_invIA;\n\tfloat32 m_invIB;\n\tfloat32 m_mass;\n};\n\n#endif\n","/*\n* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_CHAIN_SHAPE_H\n#define B2_CHAIN_SHAPE_H\n\n#include <Box2D/Collision/Shapes/b2Shape.h>\n\nclass b2EdgeShape;\n\n/// A chain shape is a free form sequence of line segments.\n/// The chain has two-sided collision, so you can use inside and outside collision.\n/// Therefore, you may use any winding order.\n/// Since there may be many vertices, they are allocated using b2Alloc.\n/// Connectivity information is used to create smooth collisions.\n/// WARNING: The chain will not collide properly if there are self-intersections.\nclass b2ChainShape : public b2Shape\n{\npublic:\n\tb2ChainShape();\n\n\t/// The destructor frees the vertices using b2Free.\n\t~b2ChainShape();\n\n\t/// Clear all data.\n\tvoid Clear();\n\n\t/// Create a loop. This automatically adjusts connectivity.\n\t/// @param vertices an array of vertices, these are copied\n\t/// @param count the vertex count\n\tvoid CreateLoop(const b2Vec2* vertices, int32 count);\n\n\t/// Create a chain with isolated end vertices.\n\t/// @param vertices an array of vertices, these are copied\n\t/// @param count the vertex count\n\tvoid CreateChain(const b2Vec2* vertices, int32 count);\n\n\t/// Establish connectivity to a vertex that precedes the first vertex.\n\t/// Don't call this for loops.\n\tvoid SetPrevVertex(const b2Vec2& prevVertex);\n\n\t/// Establish connectivity to a vertex that follows the last vertex.\n\t/// Don't call this for loops.\n\tvoid SetNextVertex(const b2Vec2& nextVertex);\n\n\t/// Implement b2Shape. Vertices are cloned using b2Alloc.\n\tb2Shape* Clone(b2BlockAllocator* allocator) const;\n\n\t/// @see b2Shape::GetChildCount\n\tint32 GetChildCount() const;\n\n\t/// Get a child edge.\n\tvoid GetChildEdge(b2EdgeShape* edge, int32 index) const;\n\n\t/// This always return false.\n\t/// @see b2Shape::TestPoint\n\tbool TestPoint(const b2Transform& transform, const b2Vec2& p) const;\n\n\t/// Implement b2Shape.\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,\n\t\t\t\t\tconst b2Transform& transform, int32 childIndex) const;\n\n\t/// @see b2Shape::ComputeAABB\n\tvoid ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;\n\n\t/// Chains have zero mass.\n\t/// @see b2Shape::ComputeMass\n\tvoid ComputeMass(b2MassData* massData, float32 density) const;\n\n\t/// The vertices. Owned by this class.\n\tb2Vec2* m_vertices;\n\n\t/// The vertex count.\n\tint32 m_count;\n\n\tb2Vec2 m_prevVertex, m_nextVertex;\n\tbool m_hasPrevVertex, m_hasNextVertex;\n};\n\ninline b2ChainShape::b2ChainShape()\n{\n\tm_type = e_chain;\n\tm_radius = b2_polygonRadius;\n\tm_vertices = NULL;\n\tm_count = 0;\n\tm_hasPrevVertex = false;\n\tm_hasNextVertex = false;\n}\n\n#endif\n","/*\n* Copyright (c) 2011 Erin Catto http://box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_DRAW_H\n#define B2_DRAW_H\n\n#include <Box2D/Common/b2Math.h>\n\n/// Color for debug drawing. Each value has the range [0,1].\nstruct b2Color\n{\n\tb2Color() {}\n\tb2Color(float32 r, float32 g, float32 b, float32 a = 1.0f) : r(r), g(g), b(b), a(a) {}\n\tvoid Set(float32 ri, float32 gi, float32 bi, float32 ai = 1.0f) { r = ri; g = gi; b = bi; a = ai; }\n\tfloat32 r, g, b, a;\n};\n\n/// Implement and register this class with a b2World to provide debug drawing of physics\n/// entities in your game.\nclass b2Draw\n{\npublic:\n\tb2Draw();\n\n\tvirtual ~b2Draw() {}\n\n\tenum\n\t{\n\t\te_shapeBit\t\t\t\t= 0x0001,\t///< draw shapes\n\t\te_jointBit\t\t\t\t= 0x0002,\t///< draw joint connections\n\t\te_aabbBit\t\t\t\t= 0x0004,\t///< draw axis aligned bounding boxes\n\t\te_pairBit\t\t\t\t= 0x0008,\t///< draw broad-phase pairs\n\t\te_centerOfMassBit\t\t= 0x0010\t///< draw center of mass frame\n\t};\n\n\t/// Set the drawing flags.\n\tvoid SetFlags(uint32 flags);\n\n\t/// Get the drawing flags.\n\tuint32 GetFlags() const;\n\t\n\t/// Append flags to the current flags.\n\tvoid AppendFlags(uint32 flags);\n\n\t/// Clear flags from the current flags.\n\tvoid ClearFlags(uint32 flags);\n\n\t/// Draw a closed polygon provided in CCW order.\n\tvirtual void DrawPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) = 0;\n\n\t/// Draw a solid closed polygon provided in CCW order.\n\tvirtual void DrawSolidPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) = 0;\n\n\t/// Draw a circle.\n\tvirtual void DrawCircle(const b2Vec2& center, float32 radius, const b2Color& color) = 0;\n\t\n\t/// Draw a solid circle.\n\tvirtual void DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color) = 0;\n\t\n\t/// Draw a line segment.\n\tvirtual void DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color) = 0;\n\n\t/// Draw a transform. Choose your own length scale.\n\t/// @param xf a transform.\n\tvirtual void DrawTransform(const b2Transform& xf) = 0;\n\nprotected:\n\tuint32 m_drawFlags;\n};\n\n#endif\n","/*\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_ROPE_JOINT_H\n#define B2_ROPE_JOINT_H\n\n#include <Box2D/Dynamics/Joints/b2Joint.h>\n\n/// Rope joint definition. This requires two body anchor points and\n/// a maximum lengths.\n/// Note: by default the connected objects will not collide.\n/// see collideConnected in b2JointDef.\nstruct b2RopeJointDef : public b2JointDef\n{\n\tb2RopeJointDef()\n\t{\n\t\ttype = e_ropeJoint;\n\t\tlocalAnchorA.Set(-1.0f, 0.0f);\n\t\tlocalAnchorB.Set(1.0f, 0.0f);\n\t\tmaxLength = 0.0f;\n\t}\n\n\t/// The local anchor point relative to bodyA's origin.\n\tb2Vec2 localAnchorA;\n\n\t/// The local anchor point relative to bodyB's origin.\n\tb2Vec2 localAnchorB;\n\n\t/// The maximum length of the rope.\n\t/// Warning: this must be larger than b2_linearSlop or\n\t/// the joint will have no effect.\n\tfloat32 maxLength;\n};\n\n/// A rope joint enforces a maximum distance between two points\n/// on two bodies. It has no other effect.\n/// Warning: if you attempt to change the maximum length during\n/// the simulation you will get some non-physical behavior.\n/// A model that would allow you to dynamically modify the length\n/// would have some sponginess, so I chose not to implement it\n/// that way. See b2DistanceJoint if you want to dynamically\n/// control length.\nclass b2RopeJoint : public b2Joint\n{\npublic:\n\tb2Vec2 GetAnchorA() const;\n\tb2Vec2 GetAnchorB() const;\n\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\n\n\t/// The local anchor point relative to bodyA's origin.\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\n\n\t/// The local anchor point relative to bodyB's origin.\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\n\n\t/// Set/Get the maximum length of the rope.\n\tvoid SetMaxLength(float32 length) { m_maxLength = length; }\n\tfloat32 GetMaxLength() const;\n\n\tb2LimitState GetLimitState() const;\n\n\t/// Dump joint to dmLog\n\tvoid Dump();\n\nprotected:\n\n\tfriend class b2Joint;\n\tb2RopeJoint(const b2RopeJointDef* data);\n\n\tvoid InitVelocityConstraints(const b2SolverData& data);\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\n\tbool SolvePositionConstraints(const b2SolverData& data);\n\n\t// Solver shared\n\tb2Vec2 m_localAnchorA;\n\tb2Vec2 m_localAnchorB;\n\tfloat32 m_maxLength;\n\tfloat32 m_length;\n\tfloat32 m_impulse;\n\n\t// Solver temp\n\tint32 m_indexA;\n\tint32 m_indexB;\n\tb2Vec2 m_u;\n\tb2Vec2 m_rA;\n\tb2Vec2 m_rB;\n\tb2Vec2 m_localCenterA;\n\tb2Vec2 m_localCenterB;\n\tfloat32 m_invMassA;\n\tfloat32 m_invMassB;\n\tfloat32 m_invIA;\n\tfloat32 m_invIB;\n\tfloat32 m_mass;\n\tb2LimitState m_state;\n};\n\n#endif\n","/*\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_POLYGON_SHAPE_H\n#define B2_POLYGON_SHAPE_H\n\n#include <Box2D/Collision/Shapes/b2Shape.h>\n\n/// A convex polygon. It is assumed that the interior of the polygon is to\n/// the left of each edge.\n/// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.\n/// In most cases you should not need many vertices for a convex polygon.\nclass b2PolygonShape : public b2Shape\n{\npublic:\n\tb2PolygonShape();\n\n\t/// Implement b2Shape.\n\tb2Shape* Clone(b2BlockAllocator* allocator) const;\n\n\t/// @see b2Shape::GetChildCount\n\tint32 GetChildCount() const;\n\n\t/// Create a convex hull from the given array of local points.\n\t/// The count must be in the range [3, b2_maxPolygonVertices].\n\t/// @warning the points may be re-ordered, even if they form a convex polygon\n\t/// @warning collinear points are handled but not removed. Collinear points\n\t/// may lead to poor stacking behavior.\n\tvoid Set(const b2Vec2* points, int32 count);\n\n\t/// Build vertices to represent an axis-aligned box centered on the local origin.\n\t/// @param hx the half-width.\n\t/// @param hy the half-height.\n\tvoid SetAsBox(float32 hx, float32 hy);\n\n\t/// Build vertices to represent an oriented box.\n\t/// @param hx the half-width.\n\t/// @param hy the half-height.\n\t/// @param center the center of the box in local coordinates.\n\t/// @param angle the rotation of the box in local coordinates.\n\tvoid SetAsBox(float32 hx, float32 hy, const b2Vec2& center, float32 angle);\n\n\t/// @see b2Shape::TestPoint\n\tbool TestPoint(const b2Transform& transform, const b2Vec2& p) const;\n\n\t/// Implement b2Shape.\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,\n\t\t\t\t\tconst b2Transform& transform, int32 childIndex) const;\n\n\t/// @see b2Shape::ComputeAABB\n\tvoid ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;\n\n\t/// @see b2Shape::ComputeMass\n\tvoid ComputeMass(b2MassData* massData, float32 density) const;\n\n\t/// Get the vertex count.\n\tint32 GetVertexCount() const { return m_count; }\n\n\t/// Get a vertex by index.\n\tconst b2Vec2& GetVertex(int32 index) const;\n\n\t/// Validate convexity. This is a very time consuming operation.\n\t/// @returns true if valid\n\tbool Validate() const;\n\n\tb2Vec2 m_centroid;\n\tb2Vec2 m_vertices[b2_maxPolygonVertices];\n\tb2Vec2 m_normals[b2_maxPolygonVertices];\n\tint32 m_count;\n};\n\ninline b2PolygonShape::b2PolygonShape()\n{\n\tm_type = e_polygon;\n\tm_radius = b2_polygonRadius;\n\tm_count = 0;\n\tm_centroid.SetZero();\n}\n\ninline const b2Vec2& b2PolygonShape::GetVertex(int32 index) const\n{\n\tb2Assert(0 <= index && index < m_count);\n\treturn m_vertices[index];\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_EDGE_SHAPE_H\n#define B2_EDGE_SHAPE_H\n\n#include <Box2D/Collision/Shapes/b2Shape.h>\n\n/// A line segment (edge) shape. These can be connected in chains or loops\n/// to other edge shapes. The connectivity information is used to ensure\n/// correct contact normals.\nclass b2EdgeShape : public b2Shape\n{\npublic:\n\tb2EdgeShape();\n\n\t/// Set this as an isolated edge.\n\tvoid Set(const b2Vec2& v1, const b2Vec2& v2);\n\n\t/// Implement b2Shape.\n\tb2Shape* Clone(b2BlockAllocator* allocator) const;\n\n\t/// @see b2Shape::GetChildCount\n\tint32 GetChildCount() const;\n\n\t/// @see b2Shape::TestPoint\n\tbool TestPoint(const b2Transform& transform, const b2Vec2& p) const;\n\n\t/// Implement b2Shape.\n\tbool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,\n\t\t\t\tconst b2Transform& transform, int32 childIndex) const;\n\n\t/// @see b2Shape::ComputeAABB\n\tvoid ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;\n\n\t/// @see b2Shape::ComputeMass\n\tvoid ComputeMass(b2MassData* massData, float32 density) const;\n\t\n\t/// These are the edge vertices\n\tb2Vec2 m_vertex1, m_vertex2;\n\n\t/// Optional adjacent vertices. These are used for smooth collision.\n\tb2Vec2 m_vertex0, m_vertex3;\n\tbool m_hasVertex0, m_hasVertex3;\n};\n\ninline b2EdgeShape::b2EdgeShape()\n{\n\tm_type = e_edge;\n\tm_radius = b2_polygonRadius;\n\tm_vertex0.x = 0.0f;\n\tm_vertex0.y = 0.0f;\n\tm_vertex3.x = 0.0f;\n\tm_vertex3.y = 0.0f;\n\tm_hasVertex0 = false;\n\tm_hasVertex3 = false;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_REVOLUTE_JOINT_H\n#define B2_REVOLUTE_JOINT_H\n\n#include <Box2D/Dynamics/Joints/b2Joint.h>\n\n/// Revolute joint definition. This requires defining an\n/// anchor point where the bodies are joined. The definition\n/// uses local anchor points so that the initial configuration\n/// can violate the constraint slightly. You also need to\n/// specify the initial relative angle for joint limits. This\n/// helps when saving and loading a game.\n/// The local anchor points are measured from the body's origin\n/// rather than the center of mass because:\n/// 1. you might not know where the center of mass will be.\n/// 2. if you add/remove shapes from a body and recompute the mass,\n///    the joints will be broken.\nstruct b2RevoluteJointDef : public b2JointDef\n{\n\tb2RevoluteJointDef()\n\t{\n\t\ttype = e_revoluteJoint;\n\t\tlocalAnchorA.Set(0.0f, 0.0f);\n\t\tlocalAnchorB.Set(0.0f, 0.0f);\n\t\treferenceAngle = 0.0f;\n\t\tlowerAngle = 0.0f;\n\t\tupperAngle = 0.0f;\n\t\tmaxMotorTorque = 0.0f;\n\t\tmotorSpeed = 0.0f;\n\t\tenableLimit = false;\n\t\tenableMotor = false;\n\t}\n\n\t/// Initialize the bodies, anchors, and reference angle using a world\n\t/// anchor point.\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);\n\n\t/// The local anchor point relative to bodyA's origin.\n\tb2Vec2 localAnchorA;\n\n\t/// The local anchor point relative to bodyB's origin.\n\tb2Vec2 localAnchorB;\n\n\t/// The bodyB angle minus bodyA angle in the reference state (radians).\n\tfloat32 referenceAngle;\n\n\t/// A flag to enable joint limits.\n\tbool enableLimit;\n\n\t/// The lower angle for the joint limit (radians).\n\tfloat32 lowerAngle;\n\n\t/// The upper angle for the joint limit (radians).\n\tfloat32 upperAngle;\n\n\t/// A flag to enable the joint motor.\n\tbool enableMotor;\n\n\t/// The desired motor speed. Usually in radians per second.\n\tfloat32 motorSpeed;\n\n\t/// The maximum motor torque used to achieve the desired motor speed.\n\t/// Usually in N-m.\n\tfloat32 maxMotorTorque;\n};\n\n/// A revolute joint constrains two bodies to share a common point while they\n/// are free to rotate about the point. The relative rotation about the shared\n/// point is the joint angle. You can limit the relative rotation with\n/// a joint limit that specifies a lower and upper angle. You can use a motor\n/// to drive the relative rotation about the shared point. A maximum motor torque\n/// is provided so that infinite forces are not generated.\nclass b2RevoluteJoint : public b2Joint\n{\npublic:\n\tb2Vec2 GetAnchorA() const;\n\tb2Vec2 GetAnchorB() const;\n\n\t/// The local anchor point relative to bodyA's origin.\n\tconst b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }\n\n\t/// The local anchor point relative to bodyB's origin.\n\tconst b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }\n\n\t/// Get the reference angle.\n\tfloat32 GetReferenceAngle() const { return m_referenceAngle; }\n\n\t/// Get the current joint angle in radians.\n\tfloat32 GetJointAngle() const;\n\n\t/// Get the current joint angle speed in radians per second.\n\tfloat32 GetJointSpeed() const;\n\n\t/// Is the joint limit enabled?\n\tbool IsLimitEnabled() const;\n\n\t/// Enable/disable the joint limit.\n\tvoid EnableLimit(bool flag);\n\n\t/// Get the lower joint limit in radians.\n\tfloat32 GetLowerLimit() const;\n\n\t/// Get the upper joint limit in radians.\n\tfloat32 GetUpperLimit() const;\n\n\t/// Set the joint limits in radians.\n\tvoid SetLimits(float32 lower, float32 upper);\n\n\t/// Is the joint motor enabled?\n\tbool IsMotorEnabled() const;\n\n\t/// Enable/disable the joint motor.\n\tvoid EnableMotor(bool flag);\n\n\t/// Set the motor speed in radians per second.\n\tvoid SetMotorSpeed(float32 speed);\n\n\t/// Get the motor speed in radians per second.\n\tfloat32 GetMotorSpeed() const;\n\n\t/// Set the maximum motor torque, usually in N-m.\n\tvoid SetMaxMotorTorque(float32 torque);\n\tfloat32 GetMaxMotorTorque() const { return m_maxMotorTorque; }\n\n\t/// Get the reaction force given the inverse time step.\n\t/// Unit is N.\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\n\n\t/// Get the reaction torque due to the joint limit given the inverse time step.\n\t/// Unit is N*m.\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\n\n\t/// Get the current motor torque given the inverse time step.\n\t/// Unit is N*m.\n\tfloat32 GetMotorTorque(float32 inv_dt) const;\n\n\t/// Dump to b2Log.\n\tvoid Dump();\n\nprotected:\n\t\n\tfriend class b2Joint;\n\tfriend class b2GearJoint;\n\n\tb2RevoluteJoint(const b2RevoluteJointDef* def);\n\n\tvoid InitVelocityConstraints(const b2SolverData& data);\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\n\tbool SolvePositionConstraints(const b2SolverData& data);\n\n\t// Solver shared\n\tb2Vec2 m_localAnchorA;\n\tb2Vec2 m_localAnchorB;\n\tb2Vec3 m_impulse;\n\tfloat32 m_motorImpulse;\n\n\tbool m_enableMotor;\n\tfloat32 m_maxMotorTorque;\n\tfloat32 m_motorSpeed;\n\n\tbool m_enableLimit;\n\tfloat32 m_referenceAngle;\n\tfloat32 m_lowerAngle;\n\tfloat32 m_upperAngle;\n\n\t// Solver temp\n\tint32 m_indexA;\n\tint32 m_indexB;\n\tb2Vec2 m_rA;\n\tb2Vec2 m_rB;\n\tb2Vec2 m_localCenterA;\n\tb2Vec2 m_localCenterB;\n\tfloat32 m_invMassA;\n\tfloat32 m_invMassB;\n\tfloat32 m_invIA;\n\tfloat32 m_invIB;\n\tb2Mat33 m_mass;\t\t\t// effective mass for point-to-point constraint.\n\tfloat32 m_motorMass;\t// effective mass for motor/limit angular constraint.\n\tb2LimitState m_limitState;\n};\n\ninline float32 b2RevoluteJoint::GetMotorSpeed() const\n{\n\treturn m_motorSpeed;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_MOUSE_JOINT_H\n#define B2_MOUSE_JOINT_H\n\n#include <Box2D/Dynamics/Joints/b2Joint.h>\n\n/// Mouse joint definition. This requires a world target point,\n/// tuning parameters, and the time step.\nstruct b2MouseJointDef : public b2JointDef\n{\n\tb2MouseJointDef()\n\t{\n\t\ttype = e_mouseJoint;\n\t\ttarget.Set(0.0f, 0.0f);\n\t\tmaxForce = 0.0f;\n\t\tfrequencyHz = 5.0f;\n\t\tdampingRatio = 0.7f;\n\t}\n\n\t/// The initial world target point. This is assumed\n\t/// to coincide with the body anchor initially.\n\tb2Vec2 target;\n\n\t/// The maximum constraint force that can be exerted\n\t/// to move the candidate body. Usually you will express\n\t/// as some multiple of the weight (multiplier * mass * gravity).\n\tfloat32 maxForce;\n\n\t/// The response speed.\n\tfloat32 frequencyHz;\n\n\t/// The damping ratio. 0 = no damping, 1 = critical damping.\n\tfloat32 dampingRatio;\n};\n\n/// A mouse joint is used to make a point on a body track a\n/// specified world point. This a soft constraint with a maximum\n/// force. This allows the constraint to stretch and without\n/// applying huge forces.\n/// NOTE: this joint is not documented in the manual because it was\n/// developed to be used in the testbed. If you want to learn how to\n/// use the mouse joint, look at the testbed.\nclass b2MouseJoint : public b2Joint\n{\npublic:\n\n\t/// Implements b2Joint.\n\tb2Vec2 GetAnchorA() const;\n\n\t/// Implements b2Joint.\n\tb2Vec2 GetAnchorB() const;\n\n\t/// Implements b2Joint.\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\n\n\t/// Implements b2Joint.\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\n\n\t/// Use this to update the target point.\n\tvoid SetTarget(const b2Vec2& target);\n\tconst b2Vec2& GetTarget() const;\n\n\t/// Set/get the maximum force in Newtons.\n\tvoid SetMaxForce(float32 force);\n\tfloat32 GetMaxForce() const;\n\n\t/// Set/get the frequency in Hertz.\n\tvoid SetFrequency(float32 hz);\n\tfloat32 GetFrequency() const;\n\n\t/// Set/get the damping ratio (dimensionless).\n\tvoid SetDampingRatio(float32 ratio);\n\tfloat32 GetDampingRatio() const;\n\n\t/// The mouse joint does not support dumping.\n\tvoid Dump() { b2Log(\"Mouse joint dumping is not supported.\\n\"); }\n\n\t/// Implement b2Joint::ShiftOrigin\n\tvoid ShiftOrigin(const b2Vec2& newOrigin);\n\nprotected:\n\tfriend class b2Joint;\n\n\tb2MouseJoint(const b2MouseJointDef* def);\n\n\tvoid InitVelocityConstraints(const b2SolverData& data);\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\n\tbool SolvePositionConstraints(const b2SolverData& data);\n\n\tb2Vec2 m_localAnchorB;\n\tb2Vec2 m_targetA;\n\tfloat32 m_frequencyHz;\n\tfloat32 m_dampingRatio;\n\tfloat32 m_beta;\n\t\n\t// Solver shared\n\tb2Vec2 m_impulse;\n\tfloat32 m_maxForce;\n\tfloat32 m_gamma;\n\n\t// Solver temp\n\tint32 m_indexA;\n\tint32 m_indexB;\n\tb2Vec2 m_rB;\n\tb2Vec2 m_localCenterB;\n\tfloat32 m_invMassB;\n\tfloat32 m_invIB;\n\tb2Mat22 m_mass;\n\tb2Vec2 m_C;\n};\n\n#endif\n","/*\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_CONTACT_H\n#define B2_CONTACT_H\n\n#include <Box2D/Common/b2Math.h>\n#include <Box2D/Collision/b2Collision.h>\n#include <Box2D/Collision/Shapes/b2Shape.h>\n#include <Box2D/Dynamics/b2Fixture.h>\n\nclass b2Body;\nclass b2Contact;\nclass b2Fixture;\nclass b2World;\nclass b2BlockAllocator;\nclass b2StackAllocator;\nclass b2ContactListener;\n\n/// Friction mixing law. The idea is to allow either fixture to drive the restitution to zero.\n/// For example, anything slides on ice.\ninline float32 b2MixFriction(float32 friction1, float32 friction2)\n{\n\treturn b2Sqrt(friction1 * friction2);\n}\n\n/// Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface.\n/// For example, a superball bounces on anything.\ninline float32 b2MixRestitution(float32 restitution1, float32 restitution2)\n{\n\treturn restitution1 > restitution2 ? restitution1 : restitution2;\n}\n\ntypedef b2Contact* b2ContactCreateFcn(\tb2Fixture* fixtureA, int32 indexA,\n\t\t\t\t\t\t\t\t\t\tb2Fixture* fixtureB, int32 indexB,\n\t\t\t\t\t\t\t\t\t\tb2BlockAllocator* allocator);\ntypedef void b2ContactDestroyFcn(b2Contact* contact, b2BlockAllocator* allocator);\n\nstruct b2ContactRegister\n{\n\tb2ContactCreateFcn* createFcn;\n\tb2ContactDestroyFcn* destroyFcn;\n\tbool primary;\n};\n\n/// A contact edge is used to connect bodies and contacts together\n/// in a contact graph where each body is a node and each contact\n/// is an edge. A contact edge belongs to a doubly linked list\n/// maintained in each attached body. Each contact has two contact\n/// nodes, one for each attached body.\nstruct b2ContactEdge\n{\n\tb2Body* other;\t\t\t///< provides quick access to the other body attached.\n\tb2Contact* contact;\t\t///< the contact\n\tb2ContactEdge* prev;\t///< the previous contact edge in the body's contact list\n\tb2ContactEdge* next;\t///< the next contact edge in the body's contact list\n};\n\n/// The class manages contact between two shapes. A contact exists for each overlapping\n/// AABB in the broad-phase (except if filtered). Therefore a contact object may exist\n/// that has no contact points.\nclass b2Contact\n{\npublic:\n\n\t/// Get the contact manifold. Do not modify the manifold unless you understand the\n\t/// internals of Box2D.\n\tb2Manifold* GetManifold();\n\tconst b2Manifold* GetManifold() const;\n\n\t/// Get the world manifold.\n\tvoid GetWorldManifold(b2WorldManifold* worldManifold) const;\n\n\t/// Is this contact touching?\n\tbool IsTouching() const;\n\n\t/// Enable/disable this contact. This can be used inside the pre-solve\n\t/// contact listener. The contact is only disabled for the current\n\t/// time step (or sub-step in continuous collisions).\n\tvoid SetEnabled(bool flag);\n\n\t/// Has this contact been disabled?\n\tbool IsEnabled() const;\n\n\t/// Get the next contact in the world's contact list.\n\tb2Contact* GetNext();\n\tconst b2Contact* GetNext() const;\n\n\t/// Get fixture A in this contact.\n\tb2Fixture* GetFixtureA();\n\tconst b2Fixture* GetFixtureA() const;\n\n\t/// Get the child primitive index for fixture A.\n\tint32 GetChildIndexA() const;\n\n\t/// Get fixture B in this contact.\n\tb2Fixture* GetFixtureB();\n\tconst b2Fixture* GetFixtureB() const;\n\n\t/// Get the child primitive index for fixture B.\n\tint32 GetChildIndexB() const;\n\n\t/// Override the default friction mixture. You can call this in b2ContactListener::PreSolve.\n\t/// This value persists until set or reset.\n\tvoid SetFriction(float32 friction);\n\n\t/// Get the friction.\n\tfloat32 GetFriction() const;\n\n\t/// Reset the friction mixture to the default value.\n\tvoid ResetFriction();\n\n\t/// Override the default restitution mixture. You can call this in b2ContactListener::PreSolve.\n\t/// The value persists until you set or reset.\n\tvoid SetRestitution(float32 restitution);\n\n\t/// Get the restitution.\n\tfloat32 GetRestitution() const;\n\n\t/// Reset the restitution to the default value.\n\tvoid ResetRestitution();\n\n\t/// Set the desired tangent speed for a conveyor belt behavior. In meters per second.\n\tvoid SetTangentSpeed(float32 speed);\n\n\t/// Get the desired tangent speed. In meters per second.\n\tfloat32 GetTangentSpeed() const;\n\n\t/// Evaluate this contact with your own manifold and transforms.\n\tvirtual void Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB) = 0;\n\nprotected:\n\tfriend class b2ContactManager;\n\tfriend class b2World;\n\tfriend class b2ContactSolver;\n\tfriend class b2Body;\n\tfriend class b2Fixture;\n\n\t// Flags stored in m_flags\n\tenum\n\t{\n\t\t// Used when crawling contact graph when forming islands.\n\t\te_islandFlag\t\t= 0x0001,\n\n        // Set when the shapes are touching.\n\t\te_touchingFlag\t\t= 0x0002,\n\n\t\t// This contact can be disabled (by user)\n\t\te_enabledFlag\t\t= 0x0004,\n\n\t\t// This contact needs filtering because a fixture filter was changed.\n\t\te_filterFlag\t\t= 0x0008,\n\n\t\t// This bullet contact had a TOI event\n\t\te_bulletHitFlag\t\t= 0x0010,\n\n\t\t// This contact has a valid TOI in m_toi\n\t\te_toiFlag\t\t\t= 0x0020\n\t};\n\n\t/// Flag this contact for filtering. Filtering will occur the next time step.\n\tvoid FlagForFiltering();\n\n\tstatic void AddType(b2ContactCreateFcn* createFcn, b2ContactDestroyFcn* destroyFcn,\n\t\t\t\t\t\tb2Shape::Type typeA, b2Shape::Type typeB);\n\tstatic void InitializeRegisters();\n\tstatic b2Contact* Create(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB, b2BlockAllocator* allocator);\n\tstatic void Destroy(b2Contact* contact, b2Shape::Type typeA, b2Shape::Type typeB, b2BlockAllocator* allocator);\n\tstatic void Destroy(b2Contact* contact, b2BlockAllocator* allocator);\n\n\tb2Contact() : m_fixtureA(NULL), m_fixtureB(NULL) {}\n\tb2Contact(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB);\n\tvirtual ~b2Contact() {}\n\n\tvoid Update(b2ContactListener* listener);\n\n\tstatic b2ContactRegister s_registers[b2Shape::e_typeCount][b2Shape::e_typeCount];\n\tstatic bool s_initialized;\n\n\tuint32 m_flags;\n\n\t// World pool and list pointers.\n\tb2Contact* m_prev;\n\tb2Contact* m_next;\n\n\t// Nodes for connecting bodies.\n\tb2ContactEdge m_nodeA;\n\tb2ContactEdge m_nodeB;\n\n\tb2Fixture* m_fixtureA;\n\tb2Fixture* m_fixtureB;\n\n\tint32 m_indexA;\n\tint32 m_indexB;\n\n\tb2Manifold m_manifold;\n\n\tint32 m_toiCount;\n\tfloat32 m_toi;\n\n\tfloat32 m_friction;\n\tfloat32 m_restitution;\n\n\tfloat32 m_tangentSpeed;\n};\n\ninline b2Manifold* b2Contact::GetManifold()\n{\n\treturn &m_manifold;\n}\n\ninline const b2Manifold* b2Contact::GetManifold() const\n{\n\treturn &m_manifold;\n}\n\ninline void b2Contact::GetWorldManifold(b2WorldManifold* worldManifold) const\n{\n\tconst b2Body* bodyA = m_fixtureA->GetBody();\n\tconst b2Body* bodyB = m_fixtureB->GetBody();\n\tconst b2Shape* shapeA = m_fixtureA->GetShape();\n\tconst b2Shape* shapeB = m_fixtureB->GetShape();\n\n\tworldManifold->Initialize(&m_manifold, bodyA->GetTransform(), shapeA->m_radius, bodyB->GetTransform(), shapeB->m_radius);\n}\n\ninline void b2Contact::SetEnabled(bool flag)\n{\n\tif (flag)\n\t{\n\t\tm_flags |= e_enabledFlag;\n\t}\n\telse\n\t{\n\t\tm_flags &= ~e_enabledFlag;\n\t}\n}\n\ninline bool b2Contact::IsEnabled() const\n{\n\treturn (m_flags & e_enabledFlag) == e_enabledFlag;\n}\n\ninline bool b2Contact::IsTouching() const\n{\n\treturn (m_flags & e_touchingFlag) == e_touchingFlag;\n}\n\ninline b2Contact* b2Contact::GetNext()\n{\n\treturn m_next;\n}\n\ninline const b2Contact* b2Contact::GetNext() const\n{\n\treturn m_next;\n}\n\ninline b2Fixture* b2Contact::GetFixtureA()\n{\n\treturn m_fixtureA;\n}\n\ninline const b2Fixture* b2Contact::GetFixtureA() const\n{\n\treturn m_fixtureA;\n}\n\ninline b2Fixture* b2Contact::GetFixtureB()\n{\n\treturn m_fixtureB;\n}\n\ninline int32 b2Contact::GetChildIndexA() const\n{\n\treturn m_indexA;\n}\n\ninline const b2Fixture* b2Contact::GetFixtureB() const\n{\n\treturn m_fixtureB;\n}\n\ninline int32 b2Contact::GetChildIndexB() const\n{\n\treturn m_indexB;\n}\n\ninline void b2Contact::FlagForFiltering()\n{\n\tm_flags |= e_filterFlag;\n}\n\ninline void b2Contact::SetFriction(float32 friction)\n{\n\tm_friction = friction;\n}\n\ninline float32 b2Contact::GetFriction() const\n{\n\treturn m_friction;\n}\n\ninline void b2Contact::ResetFriction()\n{\n\tm_friction = b2MixFriction(m_fixtureA->m_friction, m_fixtureB->m_friction);\n}\n\ninline void b2Contact::SetRestitution(float32 restitution)\n{\n\tm_restitution = restitution;\n}\n\ninline float32 b2Contact::GetRestitution() const\n{\n\treturn m_restitution;\n}\n\ninline void b2Contact::ResetRestitution()\n{\n\tm_restitution = b2MixRestitution(m_fixtureA->m_restitution, m_fixtureB->m_restitution);\n}\n\ninline void b2Contact::SetTangentSpeed(float32 speed)\n{\n\tm_tangentSpeed = speed;\n}\n\ninline float32 b2Contact::GetTangentSpeed() const\n{\n\treturn m_tangentSpeed;\n}\n\n#endif\n","/*\n* Copyright (c) 2006-2012 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_MOTOR_JOINT_H\n#define B2_MOTOR_JOINT_H\n\n#include <Box2D/Dynamics/Joints/b2Joint.h>\n\n/// Motor joint definition.\nstruct b2MotorJointDef : public b2JointDef\n{\n\tb2MotorJointDef()\n\t{\n\t\ttype = e_motorJoint;\n\t\tlinearOffset.SetZero();\n\t\tangularOffset = 0.0f;\n\t\tmaxForce = 1.0f;\n\t\tmaxTorque = 1.0f;\n\t\tcorrectionFactor = 0.3f;\n\t}\n\n\t/// Initialize the bodies and offsets using the current transforms.\n\tvoid Initialize(b2Body* bodyA, b2Body* bodyB);\n\n\t/// Position of bodyB minus the position of bodyA, in bodyA's frame, in meters.\n\tb2Vec2 linearOffset;\n\n\t/// The bodyB angle minus bodyA angle in radians.\n\tfloat32 angularOffset;\n\t\n\t/// The maximum motor force in N.\n\tfloat32 maxForce;\n\n\t/// The maximum motor torque in N-m.\n\tfloat32 maxTorque;\n\n\t/// Position correction factor in the range [0,1].\n\tfloat32 correctionFactor;\n};\n\n/// A motor joint is used to control the relative motion\n/// between two bodies. A typical usage is to control the movement\n/// of a dynamic body with respect to the ground.\nclass b2MotorJoint : public b2Joint\n{\npublic:\n\tb2Vec2 GetAnchorA() const;\n\tb2Vec2 GetAnchorB() const;\n\n\tb2Vec2 GetReactionForce(float32 inv_dt) const;\n\tfloat32 GetReactionTorque(float32 inv_dt) const;\n\n\t/// Set/get the target linear offset, in frame A, in meters.\n\tvoid SetLinearOffset(const b2Vec2& linearOffset);\n\tconst b2Vec2& GetLinearOffset() const;\n\n\t/// Set/get the target angular offset, in radians.\n\tvoid SetAngularOffset(float32 angularOffset);\n\tfloat32 GetAngularOffset() const;\n\n\t/// Set the maximum friction force in N.\n\tvoid SetMaxForce(float32 force);\n\n\t/// Get the maximum friction force in N.\n\tfloat32 GetMaxForce() const;\n\n\t/// Set the maximum friction torque in N*m.\n\tvoid SetMaxTorque(float32 torque);\n\n\t/// Get the maximum friction torque in N*m.\n\tfloat32 GetMaxTorque() const;\n\n\t/// Set the position correction factor in the range [0,1].\n\tvoid SetCorrectionFactor(float32 factor);\n\n\t/// Get the position correction factor in the range [0,1].\n\tfloat32 GetCorrectionFactor() const;\n\n\t/// Dump to b2Log\n\tvoid Dump();\n\nprotected:\n\n\tfriend class b2Joint;\n\n\tb2MotorJoint(const b2MotorJointDef* def);\n\n\tvoid InitVelocityConstraints(const b2SolverData& data);\n\tvoid SolveVelocityConstraints(const b2SolverData& data);\n\tbool SolvePositionConstraints(const b2SolverData& data);\n\n\t// Solver shared\n\tb2Vec2 m_linearOffset;\n\tfloat32 m_angularOffset;\n\tb2Vec2 m_linearImpulse;\n\tfloat32 m_angularImpulse;\n\tfloat32 m_maxForce;\n\tfloat32 m_maxTorque;\n\tfloat32 m_correctionFactor;\n\n\t// Solver temp\n\tint32 m_indexA;\n\tint32 m_indexB;\n\tb2Vec2 m_rA;\n\tb2Vec2 m_rB;\n\tb2Vec2 m_localCenterA;\n\tb2Vec2 m_localCenterB;\n\tb2Vec2 m_linearError;\n\tfloat32 m_angularError;\n\tfloat32 m_invMassA;\n\tfloat32 m_invMassB;\n\tfloat32 m_invIA;\n\tfloat32 m_invIB;\n\tb2Mat22 m_linearMass;\n\tfloat32 m_angularMass;\n};\n\n#endif\n","\n#include <Box2D/Box2D.h>\n\ntypedef b2Shape::Type b2ShapeType;\ntypedef b2ContactFeature::Type b2ContactFeatureType;\ntypedef b2Manifold::Type b2ManifoldType;\ntypedef uint32 b2DrawFlag;\n\n// Map SayGoodbye({b2Joint,b2Fixture}*) to SayGoodbye{Joint,Fixture}(..),\n// so that the JS implementation can listen for both callbacks.\nclass b2DestructionListenerWrapper : b2DestructionListener {\npublic:\n  virtual ~b2DestructionListenerWrapper() {}\n\n  virtual void SayGoodbyeJoint(b2Joint* joint) = 0;\n  virtual void SayGoodbyeFixture(b2Fixture* fixture) = 0;\n\n  void SayGoodbye(b2Joint* joint) {\n    SayGoodbyeJoint(joint);\n  }\n\n  void SayGoodbye(b2Fixture* fixture) {\n    SayGoodbyeFixture(fixture);\n  }\n};\n\n#include \"box2d_glue.cpp\"\n","/*\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#ifndef B2_WORLD_CALLBACKS_H\n#define B2_WORLD_CALLBACKS_H\n\n#include <Box2D/Common/b2Settings.h>\n\nstruct b2Vec2;\nstruct b2Transform;\nclass b2Fixture;\nclass b2Body;\nclass b2Joint;\nclass b2Contact;\nstruct b2ContactResult;\nstruct b2Manifold;\n\n/// Joints and fixtures are destroyed when their associated\n/// body is destroyed. Implement this listener so that you\n/// may nullify references to these joints and shapes.\nclass b2DestructionListener\n{\npublic:\n\tvirtual ~b2DestructionListener() {}\n\n\t/// Called when any joint is about to be destroyed due\n\t/// to the destruction of one of its attached bodies.\n\tvirtual void SayGoodbye(b2Joint* joint) = 0;\n\n\t/// Called when any fixture is about to be destroyed due\n\t/// to the destruction of its parent body.\n\tvirtual void SayGoodbye(b2Fixture* fixture) = 0;\n};\n\n/// Implement this class to provide collision filtering. In other words, you can implement\n/// this class if you want finer control over contact creation.\nclass b2ContactFilter\n{\npublic:\n\tvirtual ~b2ContactFilter() {}\n\n\t/// Return true if contact calculations should be performed between these two shapes.\n\t/// @warning for performance reasons this is only called when the AABBs begin to overlap.\n\tvirtual bool ShouldCollide(b2Fixture* fixtureA, b2Fixture* fixtureB);\n};\n\n/// Contact impulses for reporting. Impulses are used instead of forces because\n/// sub-step forces may approach infinity for rigid body collisions. These\n/// match up one-to-one with the contact points in b2Manifold.\nstruct b2ContactImpulse\n{\n\tfloat32 normalImpulses[b2_maxManifoldPoints];\n\tfloat32 tangentImpulses[b2_maxManifoldPoints];\n\tint32 count;\n};\n\n/// Implement this class to get contact information. You can use these results for\n/// things like sounds and game logic. You can also get contact results by\n/// traversing the contact lists after the time step. However, you might miss\n/// some contacts because continuous physics leads to sub-stepping.\n/// Additionally you may receive multiple callbacks for the same contact in a\n/// single time step.\n/// You should strive to make your callbacks efficient because there may be\n/// many callbacks per time step.\n/// @warning You cannot create/destroy Box2D entities inside these callbacks.\nclass b2ContactListener\n{\npublic:\n\tvirtual ~b2ContactListener() {}\n\n\t/// Called when two fixtures begin to touch.\n\tvirtual void BeginContact(b2Contact* contact) { B2_NOT_USED(contact); }\n\n\t/// Called when two fixtures cease to touch.\n\tvirtual void EndContact(b2Contact* contact) { B2_NOT_USED(contact); }\n\n\t/// This is called after a contact is updated. This allows you to inspect a\n\t/// contact before it goes to the solver. If you are careful, you can modify the\n\t/// contact manifold (e.g. disable contact).\n\t/// A copy of the old manifold is provided so that you can detect changes.\n\t/// Note: this is called only for awake bodies.\n\t/// Note: this is called even when the number of contact points is zero.\n\t/// Note: this is not called for sensors.\n\t/// Note: if you set the number of contact points to zero, you will not\n\t/// get an EndContact callback. However, you may get a BeginContact callback\n\t/// the next step.\n\tvirtual void PreSolve(b2Contact* contact, const b2Manifold* oldManifold)\n\t{\n\t\tB2_NOT_USED(contact);\n\t\tB2_NOT_USED(oldManifold);\n\t}\n\n\t/// This lets you inspect a contact after the solver is finished. This is useful\n\t/// for inspecting impulses.\n\t/// Note: the contact manifold does not include time of impact impulses, which can be\n\t/// arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly\n\t/// in a separate data structure.\n\t/// Note: this is only called for contacts that are touching, solid, and awake.\n\tvirtual void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse)\n\t{\n\t\tB2_NOT_USED(contact);\n\t\tB2_NOT_USED(impulse);\n\t}\n};\n\n/// Callback class for AABB queries.\n/// See b2World::Query\nclass b2QueryCallback\n{\npublic:\n\tvirtual ~b2QueryCallback() {}\n\n\t/// Called for each fixture found in the query AABB.\n\t/// @return false to terminate the query.\n\tvirtual bool ReportFixture(b2Fixture* fixture) = 0;\n};\n\n/// Callback class for ray casts.\n/// See b2World::RayCast\nclass b2RayCastCallback\n{\npublic:\n\tvirtual ~b2RayCastCallback() {}\n\n\t/// Called for each fixture found in the query. You control how the ray cast\n\t/// proceeds by returning a float:\n\t/// return -1: ignore this fixture and continue\n\t/// return 0: terminate the ray cast\n\t/// return fraction: clip the ray to this point\n\t/// return 1: don't clip the ray and continue\n\t/// @param fixture the fixture hit by the ray\n\t/// @param point the point of initial intersection\n\t/// @param normal the normal vector at the point of intersection\n\t/// @return -1 to filter, 0 to terminate, fraction to clip the ray for\n\t/// closest hit, 1 to continue\n\tvirtual float32 ReportFixture(\tb2Fixture* fixture, const b2Vec2& point,\n\t\t\t\t\t\t\t\t\tconst b2Vec2& normal, float32 fraction) = 0;\n};\n\n#endif\n"]}